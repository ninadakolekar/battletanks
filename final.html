
<!doctype html>
<meta charset="utf-8">
<title>Make a sprite from a texture atlas</title>
<body>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.0/pixi.min.js"></script>
 <script src="js/dust.js"></script>
<script>


var leftflag =true ;
var rightflag =true ;
var upflag =true;
var downflag=true;
var attempts =3 ;
var healthbar =5 ;
var exit = false ;
var bulletcount= 0;
var exit= false ;
var ismoving = false;


let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle;
    pi=Math.PI;


let app = new Application({
    width: 900,
    height: 900,
    antialiasing:true,
    transparent: false,
    resolution: 1
  }
);


document.body.appendChild(app.view);

let dungeon, tank, door, id, grid_t, state, move_state=38, midx, midy,healthstatus,bullet, angle, bullet_fired=false,d, bul_mov_state=38;
let bricks=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,59,60,62,63,64,65,67,68,69,70,71,72,73,74,75,76,79,80,81,82,83,84,85,86,87,89,90,92,109,119,120,122,127,128,129,130,131,132,139,149,150,151,152,156,169,179,180,186,192,199,209,210,216,218,219,220,221,222,229,239,240,246,252,259,269,270,276,277,278,279,280,282,286,287,288,289,290,291,292,293,294,295,296,297,299,300,306,312,316,329,330,336,338,339,340,341,343,344,345,346,348,359,360,366,371,378,389,390,396,397,398,399,401,403,404,405,406,408,419,420,431,436,438,439,440,441,442,443,444,445,446,447,449,450,452,453,454,454,455,456,457,458,459,460,461,463,468,479,480,491,493,494,495,496,498,500,501,502,503,509,510,521,528,533,539,540,551,553,554,555,556,558,559,560,561,563,569,570,583,587,593,599,600,602,603,604,605,606,607,608,609,610,611,612,613,617,619,620,621,622,623,629,630,640,647,653,659,660,670,677,678,679,680,681,683,689,690,700,707,713,719,720,730,743,747,748,749,750,760,767,768,769,770,771,772,777,779,780,790,807,809,810,812,813,814,815,816,817,818,819,820,823,824,825,826,827,828,829,830,831,832,834,835,836,837,839,840,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899];
let broken=[88,111,140,141,230,231,253,254,255,256,257,258,261,283,284,285,298,318,384,385,386,414,416,433,466,483,485,513,514,515,581,601,614,615,616,638,641,642,643,644,645,646,668,669,758,759,788,811];

let grid = []
let grid2 = [];
let ammo =[];
var attempts = 3 ;
var healthbar =5 ;
var exit =false ;

loader
  .add("images/sirowa.json")
  .load(setup);

function setup() {
  d= new Dust(PIXI)
  exit =false ;
  ismoving =false ;
  let dungeonTexture = TextureCache["ground.png"];
  dungeon = new Sprite(dungeonTexture);
  app.stage.addChild(dungeon);

  tank = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
  bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);

  tank.width=30;
  tank.height=30;

  tank.x = 30;
  tank.y=30;
  tank.vx = 4;
  tank.vy = 4;

  //tank.y = app.stage.height - tank.height;
  app.stage.addChild(tank);
  make_grid();
  make_ammo();


  healthstatus  = new PIXI.DisplayObjectContainer();
  healthstatus.position.set(app.stage.width - 170, 4)
  app.stage.addChild(healthstatus);

 let innerBar = new PIXI.Graphics();
 innerBar.beginFill(0x000000);
 innerBar.drawRect(0, 0, 125, 8);
 innerBar.endFill();
 healthstatus.addChild(innerBar);


 let outerBar = new PIXI.Graphics();
 outerBar.beginFill(0xFF3300);
 outerBar.drawRect(0, 0, 125, 8);
 outerBar.endFill();
 healthstatus.addChild(outerBar);
 healthstatus.outer = outerBar;

  midx=45;
  midy=45;

  let left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);
      w = keyboard(87);

      //console.log("pos "+tank.x +" "+tank.y+" piv "+tank.pivot.x+" "+tank.pivot.y);

      //console.log("pos "+tank.x +" "+tank.y+" piv "+tank.pivot.x+" "+tank.pivot.y);

          left.press = () =>{
                            	console.log("a1");
                              leftflag =true;
                              if(move_state == 37 || move_state == 39){
                              	leftloop();
                              }

                              else{
                              	rot(37);
                              }
                              tank.pivot.set(15,15);
                           };

        left.release =() => {
                            	console.log("a2");
                              leftflag =false ;

                            };

        right.press=()=>{
                        	console.log("a3");
                          rightflag =true ;
                          if(move_state == 37 || move_state == 39){
                          	rightloop();

                          }

                          else{
                          	   rot(39);
                             }
                          tank.pivot.set(15,15);
                      }

      right.release=()=>{
                        	console.log("a4");
                          rightflag =false ;

                        }

      up.press = () => {
                         	upflag=true
                         	console.log("a5");
                          if(move_state == 38 || move_state == 40){
                          	uploop();

                          }
                         	 else{
                          	rot(38);
                          }
                          tank.pivot.set(15,15);
                        };
                        up.release = () => {
                        	console.log("a6");
                          upflag =false;

                      };

   down.press = () => {
                      	console.log("a7");
                        downflag =true;
                        if(move_state == 40 || move_state == 38){
                        	downloop();
                        }

                      else{
                      	rot(40);
                      }
                     tank.pivot.set(15,15);
                     };



  down.release = () => {
                      	console.log("a8");
                        downflag =false ;
                      };

w.press =()=>{
                if(bullet_fired){
                  return;
                }
                else if (bulletcount <100)
                { //ammo[bulletcount].visible =true ;
                  bullet_fired = true;
                  //ismoving== true ;    
                  bulletcount++;
                  angle=tank.rotation;
                  state =bulletmove ;
                  console.log(bulletcount + " is the bulletcount");

                 }
                 else
                 {
                       console.log("no ammo ");
                 }

            }



  state = play;
  app.ticker.add(delta => gameLoop(delta));
  console.log("end");


  }


  function rot(r_state){
                   			let angle=pi/2.0, final, x=0, y=0;
                   			if(move_state == 38)
                        {
                   				if(r_state == 37)
                          {
                   					 angle*=-1;
                   					 y=30;
                           }
                   			  else
                          {
                   					x=30;
                   				}
                   		 }

                   			else if(move_state == 39)
                        {
                   				if(r_state == 38)
                          {
                   					angle*=-1;
                   					x=-30;
                   				}
                   				else
                          {
                   					y=30;
                   				}
                   			}
                   			else if(move_state == 40)
                        {
                   				if(r_state == 39)
                          {
                   					angle*=-1;
                   					y=-30;
                   				}
                   				else
                          {
                   					x=-30;
                   				}
                   			}
                   			else{
                   				if(r_state == 40)
                          {
                   					angle*=-1;
                   					x=30;
                   				}
                   				else
                          {
                   					y=-30;
                   				}

                   			}

                   			//requestAnimationFrame()
                   			tank.rotation+=angle;
                   			tank.x+=x;
                   			tank.y+=y;

                        for(i=bulletcount; i<100; i++){
                           ammo[i].rotation +=angle ;
                           //ammo[i].x+=x;
                      		 //ammo[i].y+=y;

                         }
                        bul_mov_state = r_state;
                   			move_state = r_state;

                   			//console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+angle+" "+pi+" "+Math.PI);
                   			console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+move_state);
   		}


function make_ammo(){
                       var bull = TextureCache["missile.png"];
                       for(i=0; i<100; i++){
                        ammo[i] = new Sprite(bull);
                        ammo[i].x =tank.x+15;
                        ammo[i].y =tank.y+15;
                        ammo[i].scale.set(0.1,0.1);
                        ammo[i].anchor.set(0.5 ,0.5);
                        ammo[i].rotation -= Math.PI*0.5 ;
                        app.stage.addChild(ammo[i]);
                        }

                   }

function make_grid(){

                      grid_t = TextureCache["tile.png"];
                      broke_t =TextureCache["broke.png"]

                      for(i=0; i<30; i++){
                        for(j=0; j<30; j++){
                          grid[i*30+j] = new Sprite(grid_t);
                          grid[i*30+j].height=30;
                          grid[i*30+j].width=30;
                          grid[i*30+j].x=30*j;
                          grid[i*30+j].y=30*i;
                          app.stage.addChild(grid[i*30+j]);
                          grid[i*30+j].visible=false;


                          grid2[i*30+j] = new Sprite(broke_t);
                          grid2[i*30+j].height=30;
                          grid2[i*30+j].width=30;
                          grid2[i*30+j].x=30*j;
                          grid2[i*30+j].y=30*i;
                          app.stage.addChild(grid2[i*30+j]);
                          grid2[i*30+j].visible=false;

                        }
                      }
                      //console.log("maze size "+bricks.length);
                      for(i=0; i<bricks.length; i++){
                          //console.log(bricks[i]);
                          grid[bricks[i]].visible=true;
                      }

                      for(i=0; i<broken.length; i++){
                        grid2[broken[i]].visible=true;
                      }
                   }


function detect_col(c_state) {
                            	let x=(midx-15)/30, y=(midy-15)/30, l, r, d, u;
                            	l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
                            	r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
                            	d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
                            	u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
                              //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
                            	if(c_state == 38 && u)
                            		return true;
                            	else if(c_state == 40 && d)
                            		return true;
                            	else if(c_state == 37 && l)
                            		return true;
                            	else if(c_state ==39 && r)
                            		return true;
                            	else
                            		return false;
                         }

function check_bul_col(c_state) {
                              let x=(ammo[bulletcount-1].x-15+(ammo[bulletcount-1].x-15)%30)/30, y=(ammo[bulletcount-1].y-15+(ammo[bulletcount-1].y-15)%30)/30, l, r, d, u;
                              l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
                              r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
                              d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
                              u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
                              //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
                              if(c_state == 38 && u){
                                if(grid2[x+(y-1)*30].visible)

                                  grid2[x+(y-1)*30].visible=false;
                                return true;
                              }
                              else if(c_state == 40 && d){
                                if(grid2[x+(y+1)*30].visible)
                                  grid2[x+(y+1)*30].visible=false;
                                return true;
                              }
                              else if(c_state == 37 && l){
                                if(grid2[(x-1)+y*30].visible)
                                  grid2[(x-1)+y*30].visible=false;
                                return true;
                              }
                              else if(c_state ==39 && r){
                                if(grid2[x+1+y*30].visible)
                                  grid2[x+1+y*30].visible=false;
                                return true;
                              }
                              else
                                return false;
}


 function bulletmove(){
                          if(ammo[bulletcount-1].x > 920 || ammo[bulletcount-1].x <-10 || ammo[bulletcount-1].y>920 || ammo[bulletcount-1].y<-10 || bullet_fired == false){
                            //console.log("bm");
                            //bullet_fired=false;
                            return;
                          }
                          //angle=tank.rotation;
                          if(check_bul_col(bul_mov_state)){
                            ammo[bulletcount-1].visible = false;
                            console.log("bullet collided with wall")
                            bullet_fired = false;
                          }
                          ammo[bulletcount-1].x += 0.5*tank.vx*Math.sin(angle);
                          ammo[bulletcount-1].y -= 0.5*tank.vy* Math.cos(angle);
                          //console.log("bullet"+ bulletcount+" has been released "+ammo[bulletcount-1].x);

                          //ismoving =false ;

                     }
 function idle(){

                     if(attempts == 0)
                     {
                       state =game_over ;
                     }
                     if(healthbar ==0 && exit == false )
                    {
                      healthbar =5 ;
                      healthstatus.outer.width =125;
                      attempts--;
                      state =play ;
                      return ;
                    }
                    //state = bulletcount;
                    //console.log(state);

              }

function game_over(){
                        console.log("game over !!!");
                        tank.visible =false ;
                        healthstatus.outer.width=0;
                        exit =true ;
                    }

  function leftloop(){
                            if(leftflag === true)
                            {
                                	if(detect_col(37) && exit ==false){
                                		console.log("collision");
                                    healthbar-- ;
                                    healthstatus.outer.width -=25 ;
                                    //state =idle ;
                                    console.log("in the idle state ");
                                    console.log(healthbar);
                                	}
                            	  else{
                                		      tank.x-=tank.vx;
                                          if(!ismoving)
                                         {
                                              for( i=bulletcount;i<100 ;i++ )
                                              {
                                                ammo[i].x -=tank.vx ;
                                              }
                                         }
                                	     console.log("l "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                                	     midx-=30;
                            	   }
                             }

                    }

  function rightloop(){
                          if(rightflag === true)
                          {
                          	if(detect_col(39) && exit ==false)
                            {
                          		console.log("collision");
                              healthbar-- ;
                              healthstatus.outer.width -=25 ;
                              //state =idle ;
                              console.log("in the idle state ");
                              console.log(healthbar);

                          	}
                          	else{
                          		tank.x+=tank.vx;
                                if(!ismoving)
                                {
                                  for( i=bulletcount;i<100 ;i++ )
                                  {
                                    ammo[i].x +=tank.vx ;
                                  }
                                }
                              	//tank.rotation += 0.01 ;
                             		 console.log("r "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                             		 midx+=30;
                              }

                            }

                    }

  function uploop(){
                      if(upflag === true )
                      {
                      	if(detect_col(38) && exit ==false){
                      		console.log("collision");
                          healthbar-- ;
                          healthstatus.outer.width -=25 ;
                          //state =idle ;
                          console.log("in the idle state ");
                          console.log(healthbar);
                      	}
                      	else{
                      		  tank.y-=tank.vy;
                            if(!ismoving)
                            {
                              for( i=bulletcount;i<100 ;i++ )
                              {
                                ammo[i].y -=tank.vy ;
                              }
                            }
                         		//tank.rotation -= 0.01 ;
                         		console.log("u "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                         		midy-=30;
                         	}
                       }
                  }

  function downloop(){
                        if(downflag === true)
                        {   //requestAnimationFrame(downloop);
                        	//setInterval(downloop,1000);
                        	if(detect_col(40) && exit ==false){
                        		console.log("collision");
                            healthbar-- ;
                            healthstatus.outer.width -=25 ;
                            //state =idle ;
                            console.log("in the idle state ");
                            console.log(healthbar);
                        	}
                        	else{
                        		tank.y+=tank.vy;
                              if(!ismoving)
                              {
                                for( i=bulletcount;i<100 ;i++ )
                                {
                                  ammo[i].y +=tank.vy ;
                                }
                              }
                            	//tank.rotation += 0.01 ;
                            	console.log("d "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                            	midy+=30;
                            }

                          }
                    }



        function keyboard(keyCode) {
          let key = {};
          key.code = keyCode;
          key.isDown = false;
          key.isUp = true;
          key.press = undefined;
          key.release = undefined;

          key.downHandler = event => {
            if (event.keyCode === key.code) {
              if (key.isUp && key.press) key.press();
              key.isDown = true;
              key.isUp = false;
            }
            event.preventDefault();
          };

          //The `upHandler`
          key.upHandler = event => {
            if (event.keyCode === key.code) {
              if (key.isDown && key.release) key.release();
              key.isDown = false;
              key.isUp = true;
            }
            event.preventDefault();
          };

          window.addEventListener(
            "keydown", key.downHandler.bind(key), false
          );
          window.addEventListener(
            "keyup", key.upHandler.bind(key), false
          );
          return key;
        }


        function gameLoop(delta){
          d.update();
          state(delta);
        }

        function play(delta) {
         tank.vx = 30;
         tank.vy= 30;

        }


  </script>
</body>

</html>
