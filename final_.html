<!doctype html>
<meta charset="utf-8">
<title>Make a sprite from a texture atlas</title>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.0/pixi.min.js"></script>
<script src="js/sound.js"></script>
<p id="demo"></p>

<script>
var leftflag =true ;
var rightflag =true ;
var upflag =true;
var downflag=true;
var attempts =3 ;
var healthbar =5 ;
var exit = false ;
var bulletcount= 0;
var ismoving = false;
var won =false;
var lost=false;
var isloaded =false;
var bullet_shot =0;
var initiliase =true ;
var center_x=0;
var center_y =0;
var other_center_x =0 ;
var other_center_y =0;


let Application = PIXI.Application,
   Container = PIXI.Container,
   loader = PIXI.loader,
   resources = PIXI.loader.resources,
   TextureCache = PIXI.utils.TextureCache,
   Sprite = PIXI.Sprite,
   Rectangle = PIXI.Rectangle;
   pi=Math.PI;

let app = new Application({
   width: 900,
   height: 900,
   antialiasing:true,
   transparent: false,
   resolution: 1
 }
);


let style = new PIXI.TextStyle({
  fontFamily: "Arial",
  fontSize: 36,
  fill: "white",
  stroke: '#ff3300',
  strokeThickness: 4,
  dropShadow: true,
  dropShadowColor: "#000000",
  dropShadowBlur: 4,
  dropShadowAngle: Math.PI / 6,
  dropShadowDistance: 6,
});

sounds.load([
  "sounds/movement.mp3",
  "sounds/collision.mp3"
]);

sounds.whenLoaded = load_comp;

document.body.appendChild(app.view);
let gamestart ,gameover;

let dungeon, tank, door, id, grid_t, state, move_state=38, midx, midy,healthstatus,bullet, angle, bullet_fired=false,d, bul_mov_state=38,movement ,collide,message1,message2,treasure;
let bricks=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,59,60,62,63,64,65,67,68,69,70,71,72,73,74,75,76,79,80,81,82,83,84,85,86,87,89,90,92,109,119,120,122,127,128,129,130,131,132,139,149,150,151,152,156,169,179,180,186,192,199,209,210,216,218,219,220,221,222,229,239,240,246,252,259,269,270,276,277,278,279,280,282,286,287,288,289,290,291,292,293,294,295,296,297,299,300,306,312,316,329,330,336,338,339,340,341,343,344,345,346,348,359,360,366,371,378,389,390,396,397,398,399,401,403,404,405,406,408,419,420,431,436,438,439,440,441,442,443,444,445,446,447,449,450,452,453,454,454,455,456,457,458,459,460,461,463,468,479,480,491,493,494,495,496,498,500,501,502,503,509,510,521,528,533,539,540,551,553,554,555,556,558,559,560,561,563,569,570,583,587,593,599,600,602,603,604,605,606,607,608,609,610,611,612,613,617,619,620,621,622,623,629,630,640,647,653,659,660,670,677,678,679,680,681,683,689,690,700,707,713,719,720,730,743,747,748,749,750,760,767,768,769,770,771,772,777,779,780,790,807,809,810,812,813,814,815,816,817,818,819,820,823,824,825,826,827,828,829,830,831,832,834,835,836,837,839,840,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899];
let broken=[88,111,140,141,230,231,253,254,255,256,257,258,261,283,284,285,298,318,384,385,386,414,416,433,466,483,485,513,514,515,581,601,614,615,616,638,641,642,643,644,645,646,668,669,758,759,788,811];
let grid = []
let grid2 = [];
let ammo =[];
let other_ammo=[];

let other_tank ,other_healthstatus ,other_bullet ,update,other_bulletcount,other_bullet_shot;



loader
 .add("images/sirowa.json")
 .load(setup);

 function load_comp(){

         movement = sounds["sounds/movement.mp3"];
         collide = sounds["sounds/collision.mp3"];
 }


function setup() {

message1 = new PIXI.Text("YOU LOST",style);
message2 =new PIXI.Text("YOU WON",style);
message1.position.set(450 ,450);
message2.position.set(450,450);


 let dungeonTexture = TextureCache["ground.png"];
 dungeon = new Sprite(dungeonTexture);
 app.stage.addChild(dungeon);

 tank = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
 other_tank = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
 bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);
other_bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);
 treasure =  new Sprite( resources["images/sirowa.json"].textures["treasure.png"]);

 tank.width=30;
 tank.height=30;
 other_tank.width=30;
 other_tank.height=30;
 treasure.width =30;
 treasure.width =30;

 tank.x = 30;
 tank.y=30;
 center_x  = 45;
 center_y =45;
 treasure.x = 450 ;
 treasure.y =840 ;
 tank.vx = 4;
 tank.vy = 4;
 other_tank.vx =4;
 other_tank.vy =4;
 //tank.y = app.stage.height - tank.height;
 app.stage.addChild(tank);
 app.stage.addChild(other_tank);
 app.stage.addChild(treasure);
 make_grid();
 make_ammo();

healthstatus  = new PIXI.DisplayObjectContainer();
healthstatus.position.set(app.stage.width - 170, 4)
app.stage.addChild(healthstatus);

let innerBar = new PIXI.Graphics();
innerBar.beginFill(0x000000);
innerBar.drawRect(0,0, 125, 8);
innerBar.endFill();
healthstatus.addChild(innerBar);

let outerBar = new PIXI.Graphics();
outerBar.beginFill(0xFF3300);
outerBar.drawRect(0, 0, 125, 8);
outerBar.endFill();
healthstatus.addChild(outerBar);
healthstatus.outer = outerBar;


other_healthstatus  = new PIXI.DisplayObjectContainer();
other_healthstatus.position.set(app.stage.width - 700, 4)
app.stage.addChild(other_healthstatus);

let iBar = new PIXI.Graphics();
iBar.beginFill(0x000000);
iBar.drawRect(0,0, 125, 8);
iBar.endFill();
other_healthstatus.addChild(iBar);

let oBar = new PIXI.Graphics();
oBar.beginFill(0xFF3300);
oBar.drawRect(0, 0, 125, 8);
oBar.endFill();
other_healthstatus.addChild(oBar);
other_healthstatus.outer = oBar;






 midx=45;
 midy=45;
 let left = keyboard(37),
     up = keyboard(38),
     right = keyboard(39),
     down = keyboard(40);
     w = keyboard(87);

      left.press = () =>{  
                            if(check_tank_col(2) && (move_state == 37 || move_state == 39)){
                              return;
                            }
                            if(exit == true)
                              {return ;}
                             console.log("a1");
                             leftflag =true;
                             if(move_state == 37 || move_state == 39){
                               leftloop();
                             }
                             else{
                               rot(37);
                             }
                             tank.pivot.set(15,15);
                          };
       left.release =() => {
                             console.log("a2");
                             leftflag =false ;
                           };

       right.press=()=>{
                        if(check_tank_col(1) && (move_state == 37 || move_state == 39)){
                              return;
                        }  
                        if(exit == true)
                          {return ;}
                         console.log("a3");
                         rightflag =true ;
                         if(move_state == 37 || move_state == 39){
                           rightloop();
                         }
                         else{
                              rot(39);
                            }
                         tank.pivot.set(15,15);
                     }
     right.release=()=>{
                         console.log("a4");
                         rightflag =false ;
                       }
     up.press = () => {
                        if(check_tank_col(4) && (move_state == 38 || move_state == 40)){
                              return;
                            }

                        if(exit == true)
                         {return ;
                        }

                         upflag=true
                         console.log("a5");
                         if(move_state == 38 || move_state == 40){
                           uploop();
                         }
                          else{
                           rot(38);
                         }
                         tank.pivot.set(15,15);
                       };
  up.release = () => {
                         console.log("a6");
                         upflag =false;
                     };
  down.press = () => {
                      if(check_tank_col(3) && (move_state == 40 || move_state == 38)){
                              return;
                      }
                      if(exit == true)
                      {return ;}
                       console.log("a7");
                       downflag =true;
                       if(move_state == 40 || move_state == 38){
                         downloop();
                       }
                     else{
                       rot(40);
                     }
                    tank.pivot.set(15,15);
                    };
 down.release = () => {
                       console.log("a8");
                       downflag =false ;
                     };

w.press =()=>{  if(exit == true)
                   {return ;}
               if(bullet_fired){
                 return;
               }
               else if (bulletcount <100)
               { //ammo[bulletcount].visible =true ;
                 bullet_fired = true;
                 //ismoving== true ;
                 bullet_shot =bulletcount ;
                 bulletcount++;
                 angle=tank.rotation;
                 bulletmove();
                 console.log(bulletcount + " is the bulletcount");
                }
                else
                {
                      console.log("no ammo ");
                }
           }
 state = play;
 app.ticker.add(delta => gameLoop(delta));
 console.log("end");
 }

 function rot(r_state){
                       let angle=pi/2.0, final, x=0, y=0;
                       if(move_state == 38)
                       {
                         if(r_state == 37)
                         {
                            angle*=-1;
                            y=30;
                          }
                         else
                         {
                           x=30;
                         }
                      }
                       else if(move_state == 39)
                       {
                         if(r_state == 38)
                         {
                           angle*=-1;
                           x=-30;
                         }
                         else
                         {
                           y=30;
                         }
                       }
                       else if(move_state == 40)
                       {
                         if(r_state == 39)
                         {
                           angle*=-1;
                           y=-30;
                         }
                         else
                         {
                           x=-30;
                         }
                       }
                       else{
                         if(r_state == 40)
                         {
                           angle*=-1;
                           x=30;
                         }
                         else
                         {
                           y=-30;
                         }
                       }
                       //requestAnimationFrame()
                       tank.rotation+=angle;
                       tank.x+=x;
                       tank.y+=y;
                       for(i=bulletcount; i<100; i++){
                          ammo[i].rotation +=angle ;
                          //ammo[i].x+=x;
                          //ammo[i].y+=y;
                        }
                       bul_mov_state = r_state;
                       move_state = r_state;
                       //console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+angle+" "+pi+" "+Math.PI);
                       console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+move_state);
     }



function make_ammo(){
                      var bull = TextureCache["missile.png"];
                      for(i=0; i<100; i++){
                       ammo[i] = new Sprite(bull);
                       ammo[i].x =tank.x+15;
                       ammo[i].y =tank.y+15;
                       ammo[i].scale.set(0.1,0.1);
                       ammo[i].anchor.set(0.5 ,0.5);
                       ammo[i].rotation -= Math.PI*0.5 ;
                       app.stage.addChild(ammo[i]);
                        //console.log("positio of bullet : "+ ammo[i].w+" "+ammo[i].height);
                        console.log("size of bullet : "+ ammo[i].width +" "+ammo[i].height);

                       }

                       for(i=0; i<100; i++){
                        other_ammo[i] = new Sprite(bull);
                        other_ammo[i].x = 15;
                        other_ammo[i].y = 15;
                        other_ammo[i].scale.set(0.1,0.1);
                        other_ammo[i].anchor.set(0.5 ,0.5);
                        other_ammo[i].rotation -= Math.PI*0.5 ;
                        other_ammo[i].visible = false;
                       app.stage.addChild(other_ammo[i]);
                  }
                }


function make_grid(){
                     grid_t = TextureCache["tile.png"];
                     broke_t =TextureCache["broke.png"]
                     for(i=0; i<30; i++){
                       for(j=0; j<30; j++){
                         grid[i*30+j] = new Sprite(grid_t);
                         grid[i*30+j].height=30;
                         grid[i*30+j].width=30;
                         grid[i*30+j].x=30*j;
                         grid[i*30+j].y=30*i;
                         app.stage.addChild(grid[i*30+j]);
                         grid[i*30+j].visible=false;
                         grid2[i*30+j] = new Sprite(broke_t);
                         grid2[i*30+j].height=30;
                         grid2[i*30+j].width=30;
                         grid2[i*30+j].x=30*j;
                         grid2[i*30+j].y=30*i;
                         app.stage.addChild(grid2[i*30+j]);
                         grid2[i*30+j].visible=false;
                       }
                     }
                     //console.log("maze size "+bricks.length);
                     for(i=0; i<bricks.length; i++){
                         //console.log(bricks[i]);
                         grid[bricks[i]].visible=true;
                     }
                     for(i=0; i<broken.length; i++){
                       grid2[broken[i]].visible=true;
                     }
                  }


function detect_col(c_state) {
                             let x=(midx-15)/30, y=(midy-15)/30, l, r, d, u;
                             l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
                             r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
                             d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
                             u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
                             //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
                             if(c_state == 38 && u)
                               return true;
                             else if(c_state == 40 && d)
                               return true;
                             else if(c_state == 37 && l)
                               return true;
                             else if(c_state ==39 && r)
                               return true;
                             else
                               return false;
                        }
function check_bul_col(c_state) {
                             let x=(ammo[bulletcount-1].x-15+(ammo[bulletcount-1].x-15)%30)/30, y=(ammo[bulletcount-1].y-15+(ammo[bulletcount-1].y-15)%30)/30, l, r, d, u;
                             l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
                             r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
                             d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
                             u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
                             //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
                             if(c_state == 38 && u){
                               if(grid2[x+(y-1)*30].visible)
                                 grid2[x+(y-1)*30].visible=false;
                               return true;
                             }
                             else if(c_state == 40 && d){
                               if(grid2[x+(y+1)*30].visible)
                                 grid2[x+(y+1)*30].visible=false;
                               return true;
                             }
                             else if(c_state == 37 && l){
                               if(grid2[(x-1)+y*30].visible)
                                 grid2[(x-1)+y*30].visible=false;
                               return true;
                             }
                             else if(c_state ==39 && r){
                               if(grid2[x+1+y*30].visible)
                                 grid2[x+1+y*30].visible=false;
                               return true;
                             }
                             else
                               return false;
}
function bulletmove(){
                         if(ammo[bulletcount-1].x > 920 || ammo[bulletcount-1].x <-10 || ammo[bulletcount-1].y>920 || ammo[bulletcount-1].y<-10 || bullet_fired == false){
                           //console.log("bm");
                           //bullet_fired=false;
                           return;
                         }
                         //angle=tank.rotation;
                         if(check_bul_col(bul_mov_state)){
                           ammo[bulletcount-1].visible = false;
                           console.log("bullet collided with wall")
                           bullet_fired = false;
                           state= play;
                         }
                         requestAnimationFrame(bulletmove);
                         ammo[bulletcount-1].x += 0.5*tank.vx*Math.sin(angle);
                         ammo[bulletcount-1].y -= 0.5*tank.vy* Math.cos(angle);

                         //console.log("bullet"+ bulletcount+" has been released "+ammo[bulletcount-1].x);
                         //ismoving =false ;
                    }


function idle(){


                  if(healthbar ==0 && exit == false )
                 {
                   healthbar =5 ;
                   healthstatus.outer.width =125;
                   attempts--;

                 }

                 if(attempts == 0)
                 {
                   tank.visible =false ;
                   healthstatus.outer.width=0;
                   exit = true ;

                 }
                state =play ;

           }

function leftloop(){
                           if(leftflag === true)
                           {
                                 if(detect_col(37) && exit ==false){
                                   console.log("collision");
                                   healthbar-- ;
                                   collide.play();
                                   healthstatus.outer.width -=25 ;
                                   idle();
                                   console.log("in the idle state ");
                                   console.log(healthbar);
                                 }
                               else{
                                         tank.x-=tank.vx;
                                         center_x-=tank.vx;
                                         if(!ismoving)
                                        {
                                             for( i=bulletcount;i<100 ;i++ )
                                             {
                                               ammo[i].x -=tank.vx ;
                                             }
                                        }
                                      console.log("l "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                                      midx-=30;
                                }
                            }
                   }
 function rightloop(){
                         if(rightflag === true)
                         {
                           if(detect_col(39) && exit ==false)
                           {
                             console.log("collision");
                             healthbar-- ;
                             collide.play();
                             healthstatus.outer.width -=25 ;
                             idle();
                             console.log("in the idle state ");
                             console.log(healthbar);
                           }
                           else{
                             tank.x+=tank.vx;
                            center_x+=tank.vx;
                               if(!ismoving)
                               {
                                 for( i=bulletcount;i<100 ;i++ )
                                 {
                                   ammo[i].x +=tank.vx ;
                                 }
                               }
                               //tank.rotation += 0.01 ;
                                console.log("r "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                                midx+=30;
                             }
                           }
                   }
 function uploop(){
                     if(upflag === true )
                     {
                       if(detect_col(38) && exit ==false){
                         console.log("collision");
                         healthbar-- ;
                         collide.play();
                         healthstatus.outer.width -=25 ;
                         idle();
                         console.log("in the idle state ");
                         console.log(healthbar);
                       }
                       else{
                           tank.y-=tank.vy;
                            center_y-=tank.vy;
                           if(!ismoving)
                           {
                             for( i=bulletcount;i<100 ;i++ )
                             {
                               ammo[i].y -=tank.vy ;
                             }
                           }
                           //tank.rotation -= 0.01 ;
                           console.log("u "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                           midy-=30;
                         }
                      }
                 }
 function downloop(){
                       if(downflag === true)
                       {   //requestAnimationFrame(downloop);
                         //setInterval(downloop,1000);
                         if(detect_col(40) && exit ==false){
                           console.log("collision");
                           healthbar-- ;
                           collide.play();
                           healthstatus.outer.width -=25 ;
                           idle();
                           console.log("in the idle state ");
                           console.log(healthbar);
                         }
                         else{
                           tank.y+=tank.vy;
                           center_y += tank.vy;
                             if(!ismoving)
                             {
                               for( i=bulletcount;i<100 ;i++ )
                               {
                                 ammo[i].y +=tank.vy ;
                               }
                             }
                             //tank.rotation += 0.01 ;
                             console.log("d "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                             midy+=30;
                           }
                         }
                   }

       function keyboard(keyCode) {
         let key = {};
         key.code = keyCode;
         key.isDown = false;
         key.isUp = true;
         key.press = undefined;
         key.release = undefined;
         key.downHandler = event => {
           if (event.keyCode === key.code) {
             if (key.isUp && key.press) key.press();
             key.isDown = true;
             key.isUp = false;
           }
           event.preventDefault();
         };
         //The `upHandler`
         key.upHandler = event => {
           if (event.keyCode === key.code) {
             if (key.isDown && key.release) key.release();
             key.isDown = false;
             key.isUp = true;
           }
           event.preventDefault();
         };
         window.addEventListener(
           "keydown", key.downHandler.bind(key), false
         );
         window.addEventListener(
           "keyup", key.upHandler.bind(key), false
         );
         return key;
       }

function player_update(){
  var bullcount = update.bulletcount;
  if(update.rot_angle !== 0)
  {
  other_tank.rotation = update.rot_angle;
  }
  else
{
  other_tank.x = update.tank_x;
  other_tank.y =update.tank_y;
  other_center_x = update.center_x;
  other_center_y = update.center_y;
}

  //console.log("player tank has been updated");

    for (var i = bullcount; i < 100; i++)
    { if(update.rot_angle !== 0)
      {other_ammo[i].rotation =update.rot_angle ;}
      else
      {  other_ammo[i].x =update.other_x ;
         other_ammo[i].y =update.other_y;
      }
      other_ammo[i].visible =true ;

    }

  other_healthstatus.outer.width = update.outer;
  detect_tc();
  detect_tb();
  //check collision of tank with the wall
  //other_tank.bullet =update.bullet_x;
}

function detect_tc()
{
  if( Math.pow(other_center_x -center_x ,2)  +   Math.pow(other_center_y -center_y ,2) <=900)
  {
      console.log("tank collision detected");
      return true;

  }
  return false;
}

function detect_tb()
{
 if(Math.pow(update.bullet_x -center_x ,2)  +   Math.pow(update.bullet_y -center_y ,2) <=450)
 {
   console.log("bullet tank collision detected");
   return true;
 }
 return false;
}

function check_tank_col(num){
  //console.log("tank_col "+num);
  if(midx < other_center_x && num == 1 && detect_tc()){
    console.log("tank_col "+1)
    return true;
  }
  else if(midx > other_center_x && num == 2 && detect_tc()){
    console.log("tank_col "+2)
    return true;
  }
  else if(midy < other_center_y && num == 3 && detect_tc()){
    console.log("tank_col "+3)
    return true;
  }
  else if(midy > other_center_y && num == 4 && detect_tc()){
    console.log("tank_col "+4)
    return true;
  }
  console.log("tank_col false "+midx+" "+other_center_x);
  return false;
}




function gameLoop(delta){
          if(lost ==true || won== true || exit==true)
         {
           return;
         }

         state(delta);
       }

function play(delta) {
        tank.vx = 30;
        tank.vy= 30;
        //console.log("play all the time \n");
         if (exit== true){

           for(i=0 ;i<100 ;i++){
             ammo[i].visible = false ;
             ammo[i].vx=0;
             ammo[i].vy= 0;
           }

           tank.visible = false;
           tank.vx =0;
           tank.vy =0;
          /* for(i=0; i<bricks.length; i++){
               //console.log(bricks[i]);
               grid[bricks[i]].visible=false;
           }

           for(i=0; i<broken.length; i++){
             grid2[broken[i]].visible=false;
           }*/
           //dungeon.visible =false ;
           //app.stage.addChild(message1);
          return ;}


          if(tank.x ==treasure.x && tank.y ==treasure.y)
          {
            for(i=0 ;i<100 ;i++){
              ammo[i].visible = false ;
              tank.vx=0;
              tank.vy= 0;
            }
            for(i=0; i<bricks.length; i++){
                //console.log(bricks[i]);
                grid[bricks[i]].visible=false;
            }

            for(i=0; i<broken.length; i++){
              grid2[broken[i]].visible=false;
            }
            tank.visible =false;
            treasure.visible=false;
            dungeon.visible =false ;
            app.stage.addChild(message2);
            won =true ;
           return ;

          }

          var  other_player ={ "tank_x" : 90+30,
                               "tank_y" : 30+90,
                               "rot_angle":0,  //only increment
                               "bulletcount":30,
                               "bullet_x":105,          //first invoke this function
                               "bullet_y":45,
                               "other_x":15,
                               "other_y":45,
                               "attempts":3 ,
                               "center_x":105+30,
                               "center_y":45+90,
                               "outer": 25 ,
                               "exit": false,
                               "won":false

                              } ;
          var fg =  JSON.stringify(other_player);
          update  = JSON.parse(fg);


          if(update.won == true)
          {
                for(i=0 ;i<100 ;i++){
                  ammo[i].visible = false ;
                  ammo[i].vx=0;
                  ammo[i].vy= 0;
                }

                tank.visible = false;
                tank.vx =0;
                tank.vy =0;
               for(i=0; i<bricks.length; i++){
                    //console.log(bricks[i]);
                    grid[bricks[i]].visible=false;
                }

                for(i=0; i<broken.length; i++){
                  grid2[broken[i]].visible=false;
                }
                dungeon.visible =false ;
                app.stage.addChild(message1);
                lost =true;
               return ;

          }

         player_update();

       var  object_of_player ={ "tank_x" :tank.x ,
                                "tank_y" :tank.y ,
                                "rot_angle":angle,
                                "bulletcount":bulletcount ,
                                "bullet_x":ammo[bullet_shot].x,
                                "bullet_y":ammo[bullet_shot].y,
                                "other_x":ammo[bulletcount].x,
                                "other_y":ammo[bulletcount].y,
                                "attempts":attempts ,
                                "center_x":center_x,
                                "center_y":center_y,
                                "outer": healthstatus.outer.width ,
                                "exit": exit,
                                "won": won


                             } ;
      var ed = JSON.stringify(object_of_player);
     document.getElementById("demo").innerHTML = ed;

       }
 </script>
</body>

</html>
