<!doctype html>
<meta charset="utf-8">
<title>Make a sprite from a texture atlas</title>
<body>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.0/pixi.min.js"></script>
 <script src="js/maze.js"></script>
<script>


//console.log("dfs"+Math.pi);
var leftflag =true ;
var rightflag =true ;
var upflag =true;
var downflag=true;


//Aliases
let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle;
    pi=Math.PI;


let app = new Application({
    width: 900,
    height: 900,
    antialiasing:true,
    transparent: false,
    resolution: 1
  }
);


document.body.appendChild(app.view);

let dungeon, tank, door, id, grid_t, state, move_state=38, midx, midy;

let grid = []
let grid2 = [];

loader
  .add("images/tank.json")
  .load(setup);

function setup() {

  let dungeonTexture = TextureCache["ground.png"];
  dungeon = new Sprite(dungeonTexture);
  dungeon.width=900;
  dungeon.height=900;
  app.stage.addChild(dungeon);

  tank = new Sprite(
    resources["images/tank.json"].textures["tank12.png"]
  );

  make_grid();

  tank.width=30;
  tank.height=30;
  tank.x = 30;
  tank.y=30;
  tank.vx = 30;
  tank.vy = 30;

  //tank.y = app.stage.height - tank.height;
  app.stage.addChild(tank);
  midx=45;
  midy=45;
  let left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);

          //tank.anchor.set(0.5 ,0.5);
          console.log("pos "+tank.x +" "+tank.y+" piv "+tank.pivot.x+" "+tank.pivot.y);
          tank.pivot.set(15,15);
          console.log("pos "+tank.x +" "+tank.y+" piv "+tank.pivot.x+" "+tank.pivot.y);

          left.press = () =>{
          	console.log("a1");
            leftflag =true;
            if(move_state == 37 || move_state == 39){
            	leftloop();
            	//tank.x-=30;
            }
           /* else if(move_state == 39){
            	//move_state=37;
            	//tank.x+=30;
            	rightloop();

            }*/
            else{
            	rot(37);
            }
            tank.pivot.set(15,15);
          };

          left.release =() => {
          	console.log("a2");
            leftflag =false ;

          //console.log(tank.x +" "+tank.y);
          };

          right.press=()=>{
          	console.log("a3");
            rightflag =true ;
            if(move_state == 37 || move_state == 39){
            	rightloop();
            	//tank.x+=30;
            }
            /*else if(move_state == 39){
            	leftloop();
            	//tank.x-=30;
            	move_state=37;
            }*/
            else{
            	rot(39);
            } 
            tank.pivot.set(15,15);            
          }

          right.release=()=>{
          	console.log("a4");
            rightflag =false ;
            //console.log(tank.x +" "+tank.y);
          }

           up.press = () => {
           	upflag=true
           	console.log("a5");
            if(move_state == 38 || move_state == 40){
            	uploop();
            	//moveup();
            	//tank.y+=30;
            }
            /*else if(move_state == 40){
            	downloop();
            	//tank.y-=30;
            	move_state=38;
            }*/
           	 else{
            	rot(38);
            }     
            tank.pivot.set(15,15);      
          };
          up.release = () => {
          	console.log("a6");
            upflag =false;

          };

          down.press = () => {
          	console.log("a7");
            downflag =true;
            if(move_state == 40 || move_state == 38){
            	downloop();
            	//movedown();
            	//tank.y-=30;
            }
            /*else if(move_state == 38){
            	//tank.y+=30;
            	uploop();
            	move_state=40;
            }*/
            else{
            	rot(40);
            }      
            tank.pivot.set(15,15);    
          };
          down.release = () => {
          	console.log("a8");
            downflag =false ;
          };

        state = play;
        app.ticker.add(delta => gameLoop(delta));
        console.log("end");
        }


   		function rot(r_state){
   			let angle=pi/2.0, final, x=0, y=0;
   			if(move_state == 38){
   				if(r_state == 37){
   					angle*=-1;
   					y=30;
   					/*while(tank.rotation < pi/2.0)
   						tank.rotation+=0.0001;
   					tank.rotation=pi/2.0;*/
   				}
   				else{
   					x=30;
   				}
   			}
   			else if(move_state == 39){
   				if(r_state == 38){
   					angle*=-1;
   					x=-30;
   				}
   				else{
   					y=30;
   				}
   			}
   			else if(move_state == 40){
   				if(r_state == 39){
   					angle*=-1;
   					y=-30;
   				}
   				else{
   					x=-30;
   				}
   			}
   			else{
   				if(r_state == 40){
   					angle*=-1;
   					x=30;
   				}
   				else{
   					y=-30;
   				}
   			}

   			//requestAnimationFrame()
   			tank.rotation+=angle;
   			tank.x+=x;
   			tank.y+=y;
   			move_state = r_state;

   			//console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+angle+" "+pi+" "+Math.PI);
   			console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+move_state);
   		}



  function make_grid(){

  grid_t = TextureCache["tile.png"];
  broke_t =TextureCache["broke.png"]

  for(i=0; i<30; i++){
    for(j=0; j<30; j++){
      grid[i*30+j] = new Sprite(grid_t);
      grid[i*30+j].height=30;
      grid[i*30+j].width=30;
      grid[i*30+j].x=30*j;
      grid[i*30+j].y=30*i;
      app.stage.addChild(grid[i*30+j]);
      grid[i*30+j].visible=false;


      grid2[i*30+j] = new Sprite(broke_t);
      grid2[i*30+j].height=30;
      grid2[i*30+j].width=30;
      grid2[i*30+j].x=30*j;
      grid2[i*30+j].y=30*i;
      app.stage.addChild(grid2[i*30+j]);
      grid2[i*30+j].visible=false;

    }
  }
  //console.log("maze size "+bricks.length);
  for(i=0; i<bricks.length; i++){
      //console.log(bricks[i]);
      grid[bricks[i]].visible=true;	
  }

  for(i=0; i<broken.length; i++){
    grid2[broken[i]].visible=true;
  }
}


function detect_col(c_state) {
	let x=(midx-15)/30, y=(midy-15)/30, l, r, d, u;
	l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
	r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
	d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
	u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
  console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
	if(c_state == 38 && u)
		return true;
	else if(c_state == 40 && d)
		return true;
	else if(c_state == 37 && l)
		return true;
	else if(c_state ==39 && r)
		return true;
	else
		return false;
}

  function leftloop(){
    if(leftflag === true)
    {  //requestAnimationFrame(leftloop);
    	//setInterval(leftloop,1000);
    	if(detect_col(37)){
    		console.log("collision");
    	}
    	else{
    		tank.x-=tank.vx;
    	   //tank.rotation -= 0.01 ;
    	   console.log("l "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
    	   midx-=30;
    	}
     }

  }

  function rightloop(){
    if(rightflag === true)
    {   //requestAnimationFrame(rightloop);
    	//setInterval(rightloop,1000);
    	if(detect_col(39)){
    		console.log("collision");
    	}
    	else{
    		tank.x+=tank.vx;
        	//tank.rotation += 0.01 ;
       		 console.log("r "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
       		 midx+=30;
        }

      }

  }

  function uploop(){
    if(upflag === true)
    {  //requestAnimationFrame(uploop);
    	//setInterval(uploop,1000);
    	if(detect_col(38)){
    		console.log("collision");
    	}
    	else{
    		tank.y-=tank.vy;
       		//tank.rotation -= 0.01 ;
       		console.log("u "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
       		midy-=30;
       	}
     }

  }

  function downloop(){
    if(downflag === true)
    {   //requestAnimationFrame(downloop);
    	//setInterval(downloop,1000);
    	if(detect_col(40)){
    		console.log("collision");
    	}
    	else{
    		tank.y+=tank.vy;
        	//tank.rotation += 0.01 ;
        	console.log("d "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
        	midy+=30;
        }

      }

  }



        function keyboard(keyCode) {
          let key = {};
          key.code = keyCode;
          key.isDown = false;
          key.isUp = true;
          key.press = undefined;
          key.release = undefined;

          key.downHandler = event => {
            if (event.keyCode === key.code) {
              if (key.isUp && key.press) key.press();
              key.isDown = true;
              key.isUp = false;
            }
            event.preventDefault();
          };

          //The `upHandler`
          key.upHandler = event => {
            if (event.keyCode === key.code) {
              if (key.isDown && key.release) key.release();
              key.isDown = false;
              key.isUp = true;
            }
            event.preventDefault();
          };

          window.addEventListener(
            "keydown", key.downHandler.bind(key), false
          );
          window.addEventListener(
            "keyup", key.upHandler.bind(key), false
          );
          return key;
        }

        /*function moveup() {
          if(upflag==true)
          {
            requestAnimationFrame(moveup);
          tank.x+= tank.vx* Math.sin(tank.rotation);
          tank.y-=tank.vy* Math.cos(tank.rotation);}
        }

        function movedown(){

          if(downflag==true)
          {  requestAnimationFrame(movedown);
             tank.x-= tank.vx* Math.sin(tank.rotation);
             tank.y+=tank.vy* Math.cos(tank.rotation);}

        }*/

        function gameLoop(delta){
          state(delta);
        }

        function play(delta) {
         tank.vx = 30;
         tank.vy= 30;

        }


  </script>
</body>

</html>
