<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Battle tanks </title>
</head>

<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.0/pixi.min.js"></script>

<script src="js/sound.js"></script>

<p id="demo"></p>

<script>

var leftflag =true ;
var rightflag =true ;
var myID;
var myIDset =false;
var angle_1;

var upflag =true;
var downflag=true;
var hit_wall =false;

var attempts =3 ;
var healthbar =5 ;

var exit = false ;
var bulletcount= 0;

var ismoving = false;
var won =false;
var lost=false;
var isloaded =false;
var bullet_shot =0;
var initiliase =true ;

var center_x=0;
var center_y =0;

var other_center_x =0 ;
var other_center_y =0;
var socket = new WebSocket("ws://localhost:8080/");
var update;
var broken_tile=-1;
var x=0;
var y=0;

let Application = PIXI.Application,
   Container = PIXI.Container,
   loader = PIXI.loader,
   resources = PIXI.loader.resources,
   TextureCache = PIXI.utils.TextureCache,
   Sprite = PIXI.Sprite,
   Rectangle = PIXI.Rectangle;
   pi=Math.PI;

let app = new Application({
   width: 900,
   height: 900,
   antialiasing:true,
   transparent: false,
   resolution: 1
 }
);


let style = new PIXI.TextStyle({
  fontFamily: "Arial",
  fontSize: 36,
  fill: "white",
  stroke: '#ff3300',
  strokeThickness: 4,
  dropShadow: true,
  dropShadowColor: "#000000",
  dropShadowBlur: 4,
  dropShadowAngle: Math.PI / 6,
  dropShadowDistance: 6,
});

sounds.load([
  "sounds/movement.mp3",
  "sounds/collision.mp3"
]);

sounds.whenLoaded = load_comp;

document.body.appendChild(app.view);
let gamestart ,gameover;

let dungeon, tank, door, id, grid_t, state, move_state=38, midx, midy,healthstatus,bullet, angle, bullet_fired=false,d, bul_mov_state=38,movement ,collide,message1,message2,treasure;
let bricks=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,59,60,62,63,64,65,67,68,69,70,71,72,73,74,75,76,79,80,81,82,83,84,85,86,87,89,90,92,109,119,120,122,127,128,129,130,131,132,139,149,150,151,152,156,169,179,180,186,192,199,209,210,216,218,219,220,221,222,229,239,240,246,252,259,269,270,276,277,278,279,280,282,286,287,288,289,290,291,292,293,294,295,296,297,299,300,306,312,316,329,330,336,338,339,340,341,343,344,345,346,348,359,360,366,371,378,389,390,396,397,398,399,401,403,404,405,406,408,419,420,431,436,438,439,440,441,442,443,444,445,446,447,449,450,452,453,454,454,455,456,457,458,459,460,461,463,468,479,480,491,493,494,495,496,498,500,501,502,503,509,510,521,528,533,539,540,551,553,554,555,556,558,559,560,561,563,569,570,583,587,593,599,600,602,603,604,605,606,607,608,609,610,611,612,613,617,619,620,621,622,623,629,630,640,647,653,659,660,670,677,678,679,680,681,683,689,690,700,707,713,719,720,730,743,747,748,749,750,760,767,768,769,770,771,772,777,779,780,790,807,809,810,812,813,814,815,816,817,818,819,820,823,824,825,826,827,828,829,830,831,832,834,835,836,837,839,840,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899];
let broken=[88,111,140,141,230,231,253,254,255,256,257,258,261,283,284,285,298,318,384,385,386,414,416,433,466,483,485,513,514,515,581,601,614,615,616,638,641,642,643,644,645,646,668,669,758,759,788,811];
let grid = []
let grid2 = [];
let ammo =[];
let other_ammo=[];

let other_tank ,other_healthstatus ,other_bullet ,other_bulletcount,other_bullet_shot;
var setupDone = false;


function sendUpdate() {
         var updateObject = {   

        "id":myID,
        "message":"updateResponse",
        "tank_x" :tank.x ,
        "tank_y" :tank.y ,
        "rotationIncrement":angle,
        "bulletCount":bulletcount ,
        "bullet_x":ammo[bullet_shot].x,
        "bullet_y":ammo[bullet_shot].y,
        "other_x":ammo[bulletcount].x,
        "other_y":ammo[bulletcount].y,
        "center_x":center_x,
        "center_y":center_y,
        "health": healthstatus.outer.width ,
        "exit": exit,
        "won": won,
        "tile_index":broken_tile ,
        "hitwall":hit_wall

        } ;
        angle=0;
        broken_tile=-1;
        //healthstatus.outer.width =0;

      socket.send(JSON.stringify(updateObject));

}


function applyUpdate(msg) {

     update = msg ;

   if(msg.id != myID) {
    
    if(msg.exit==true){
      console.log("exit...")

      for (var i = msg.bulletCount; i < 100; i++) { 

        other_ammo[i].visible =false;
      }

      other_tank.visible =false;
      
      return;
    }
    else {
      console.log("other tank  visibe true");
      other_tank.visible =true;
    }


    if(msg.rotationIncrement != 0) {

      other_tank.rotation += msg.rotationIncrement;

    } 
    
    else {

      other_tank.x = msg.tank_x;
      other_tank.y = msg.tank_y;

      other_center_x = msg.center_x;
      other_center_y = msg.center_y;
      console.log("Coords");

    }

 


    for (var i = msg.bulletCount; i < 100; i++) { 

       if(msg.rotationIncrement != 0){
        other_ammo[i].rotation += msg.rotationIncrement ;}
      
       else{  
        other_ammo[i].x =msg.other_x ;
        other_ammo[i].y =msg.other_y;}
      

       other_ammo[i].visible =true ;

    } 

    other_bulletcount = msg.bulletCount;

    if(msg.bulletCount !== 0){
      other_ammo[msg.bulletCount-1].x =msg.bullet_x ;
      other_ammo[msg.bulletCount-1].y =msg.bullet_y ;
       if(msg.hitwall == true)
       { other_ammo[msg.bulletCount-1].visible =false ;
         console.log("bullet has hit the wall");
          msg.hitwall =false ;
        }
       else
        { detect_tb();}
       

    }

    other_healthstatus.outer.width = msg.health;

    if(msg.tile_index !=-1)
    {
     grid2[msg.tile_index].visible =false;

    }
  
    
    //coll_tc();
 

    if(update.won == true)
          {
                for(i=0 ;i<100 ;i++){
                  ammo[i].visible = false ;
                  ammo[i].vx=0;
                  ammo[i].vy= 0;
                }

                tank.visible = false;
                tank.vx =0;
                tank.vy =0;

                for(i=0; i<bricks.length; i++){
                    //console.log(bricks[i]);
                    grid[bricks[i]].visible=false;
                }

                for(i=0; i<broken.length; i++){
                  grid2[broken[i]].visible=false;
                }

                dungeon.visible =false ;
                app.stage.addChild(message1);
                lost =true;
               return ;

          }



  }

}

socket.onopen = function(){
        alert("Websocket Connection Established!!");
        loader
       .add("images/sirowa.json")
      .load(setup);
};

socket.onmessage = function (evt) { 
                    var received_msg  = evt.data;
                    var msg_obj = JSON.parse(received_msg)
                  if(msg_obj.message == "requestUpdate") {if(setupDone==true) sendUpdate();}
                  else if(msg_obj.message == "notifyID") {var x = msg_obj.id; console.log("Me User: ",x);myID = x;myIDset=true;}
                  else if(msg_obj.message == "applyUpdate") {if(setupDone==true) {applyUpdate(msg_obj);console.log("applyUpdate: ",msg_obj);}}
};

 function load_comp(){

         movement = sounds["sounds/movement.mp3"];
         collide = sounds["sounds/collision.mp3"];
 }


function setup() {

message1 = new PIXI.Text("YOU LOST",style);
message2 =new PIXI.Text("YOU WON",style);
message1.position.set(450 ,450);
message2.position.set(450,450);


 let dungeonTexture = TextureCache["ground.png"];
 dungeon = new Sprite(dungeonTexture);
 app.stage.addChild(dungeon);

 tank = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
 other_tank = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
 bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);
 other_bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);
 treasure =  new Sprite( resources["images/sirowa.json"].textures["treasure.png"]);

 tank.width=30;
 tank.height=30;
 other_tank.width=30;
 other_tank.height=30;
 treasure.width =50;
 treasure.height =30;
 while(!myIDset){};
if(myID%2==0)
{
 tank.x = 30;
 tank.y=30;
 midx = 45;
 midy =45;
 center_x = 45;
 center_y =45;
}
else{
  tank.x =840;
  tank.y=840;
  midx =855;
  midy=855;
  center_x =855;
  center_y =855;

}

 treasure.x = 425 ;
 treasure.y =435 ;
 tank.vx = 4;
 tank.vy = 4;
 other_tank.vx =4;
 other_tank.vy =4;
 //tank.y = app.stage.height - tank.height;
 app.stage.addChild(tank);
 app.stage.addChild(other_tank);
 app.stage.addChild(treasure);
 make_grid();
 make_ammo();

healthstatus  = new PIXI.DisplayObjectContainer();
healthstatus.position.set(app.stage.width - 170, 4)
app.stage.addChild(healthstatus);

let innerBar = new PIXI.Graphics();
innerBar.beginFill(0x000000);
innerBar.drawRect(0,0, 125, 8);
innerBar.endFill();
healthstatus.addChild(innerBar);

let outerBar = new PIXI.Graphics();
outerBar.beginFill(0xFF3300);
outerBar.drawRect(0, 0, 125, 8);
outerBar.endFill();
healthstatus.addChild(outerBar);
healthstatus.outer = outerBar;


other_healthstatus  = new PIXI.DisplayObjectContainer();
other_healthstatus.position.set(app.stage.width - 700, 4)
app.stage.addChild(other_healthstatus);

let iBar = new PIXI.Graphics();
iBar.beginFill(0x000000);
iBar.drawRect(0,0, 125, 8);
iBar.endFill();
other_healthstatus.addChild(iBar);

let oBar = new PIXI.Graphics();
oBar.beginFill(0xFF3300);
oBar.drawRect(0, 0, 125, 8);
oBar.endFill();
other_healthstatus.addChild(oBar);
other_healthstatus.outer = oBar;



 /*midx=45;
 midy=45;*/
 let left = keyboard(37),
     up = keyboard(38),
     right = keyboard(39),
     down = keyboard(40);
     w = keyboard(87);

      left.press = () =>{
                            if(check_tank_col(2) && (move_state == 37 || move_state == 39)){
                              return;
                            }
                            if(exit == true)
                              {return ;}
                             console.log("a1");
                             leftflag =true;
                             if(move_state == 37 || move_state == 39){
                               leftloop();
                             }
                             else{
                               rot(37);
                             }
                             tank.pivot.set(15,15);
                          };
       left.release =() => {
                             console.log("a2");
                             leftflag =false ;
                           };

       right.press=()=>{
                        if(check_tank_col(1) && (move_state == 37 || move_state == 39)){
                              return;
                        }
                        if(exit == true)
                          {return ;}
                         console.log("a3");
                         rightflag =true ;
                         if(move_state == 37 || move_state == 39){
                           rightloop();
                         }
                         else{
                              rot(39);
                            }
                         tank.pivot.set(15,15);
                     }
     right.release=()=>{
                         console.log("a4");
                         rightflag =false ;
                       }
     up.press = () => {
                        if(check_tank_col(4) && (move_state == 38 || move_state == 40)){
                              return;
                            }

                        if(exit == true)
                         {return ;
                        }

                         upflag=true
                         console.log("a5");
                         if(move_state == 38 || move_state == 40){
                           uploop();
                         }
                          else{
                           rot(38);
                         }
                         tank.pivot.set(15,15);
                       };
  up.release = () => {
                         console.log("a6");
                         upflag =false;
                     };
  down.press = () => {
                      if(check_tank_col(3) && (move_state == 40 || move_state == 38)){
                              return;
                      }
                      if(exit == true)
                      {return ;}
                       console.log("a7");
                       downflag =true;
                       if(move_state == 40 || move_state == 38){
                         downloop();
                       }
                     else{
                       rot(40);
                     }
                    tank.pivot.set(15,15);
                    };
 down.release = () => {
                       console.log("a8");
                       downflag =false ;
                     };

w.press =()=>{  if(exit == true)
                   {return ;}
               if(bullet_fired){
                 return;
               }
               else if (bulletcount <100)
               { //ammo[bulletcount].visible =true ;
                 bullet_fired = true;
                 //ismoving== true ;
                 bullet_shot =bulletcount ;
                 bulletcount++;
                 angle_1=tank.rotation;
                 bulletmove();
                 console.log(bulletcount + " is the bulletcount");
                }
                else
                {
                      console.log("no ammo ");
                }
           }

 state = play;
 app.ticker.add(delta => gameLoop(delta));
 setupDone = true;
 console.log("end");

 }

 function hitTestRectangle(r1, r2) {

  //Define the variables we'll need to calculate
  let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

  //hit will determine whether there's a collision
  hit = false;

  //Find the center points of each sprite
  r1.centerX = r1.x + r1.width / 2;
  r1.centerY = r1.y + r1.height / 2;
  r2.centerX = r2.x + r2.width / 2;
  r2.centerY = r2.y + r2.height / 2;

  //Find the half-widths and half-heights of each sprite
  r1.halfWidth = r1.width / 2;
  r1.halfHeight = r1.height / 2;
  r2.halfWidth = r2.width / 2;
  r2.halfHeight = r2.height / 2;

  //Calculate the distance vector between the sprites
  vx = r1.centerX - r2.centerX;
  vy = r1.centerY - r2.centerY;

  //Figure out the combined half-widths and half-heights
  combinedHalfWidths = r1.halfWidth + r2.halfWidth;
  combinedHalfHeights = r1.halfHeight + r2.halfHeight;

  //Check for a collision on the x axis
  if (Math.abs(vx) < combinedHalfWidths) {

    //A collision might be occuring. Check for a collision on the y axis
    if (Math.abs(vy) < combinedHalfHeights) {

      //There's definitely a collision happening
      hit = true;
    } else {

      //There's no collision on the y axis
      hit = false;
    }
  } else {

    //There's no collision on the x axis
    hit = false;
  }

  //`hit` will be either `true` or `false`
  return hit;
};



 function rot(r_state){
                       angle=pi/2.0;
                       let final, x=0, y=0;
                       if(move_state == 38)
                       {
                         if(r_state == 37)
                         {
                            angle*=-1;
                            y=30;
                          }
                         else
                         {
                           x=30;
                         }
                      }
                       else if(move_state == 39)
                       {
                         if(r_state == 38)
                         {
                           angle*=-1;
                           x=-30;
                         }
                         else
                         {
                           y=30;
                         }
                       }
                       else if(move_state == 40)
                       {
                         if(r_state == 39)
                         {
                           angle*=-1;
                           y=-30;
                         }
                         else
                         {
                           x=-30;
                         }
                       }
                       else{
                         if(r_state == 40)
                         {
                           angle*=-1;
                           x=30;
                         }
                         else
                         {
                           y=-30;
                         }
                       }
                       //requestAnimationFrame()
                       tank.rotation+=angle;
                       tank.x+=x;
                       tank.y+=y;
                       for(i=bulletcount; i<100; i++){
                          ammo[i].rotation +=angle ;
                          //ammo[i].x+=x;
                          //ammo[i].y+=y;
                        }
                       bul_mov_state = r_state;
                       move_state = r_state;
                       //console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+angle+" "+pi+" "+Math.PI);
                       console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+move_state);
     }



function make_ammo(){
                      var bull = TextureCache["missile.png"];
                      for(i=0; i<100; i++){
                       ammo[i] = new Sprite(bull);
                       ammo[i].x =tank.x+15;
                       ammo[i].y =tank.y+15;
                       ammo[i].scale.set(0.1,0.1);
                       ammo[i].anchor.set(0.5 ,0.5);
                       ammo[i].rotation -= Math.PI*0.5 ;
                       app.stage.addChild(ammo[i]);
                        //console.log("positio of bullet : "+ ammo[i].w+" "+ammo[i].height);
                        console.log("size of bullet : "+ ammo[i].width +" "+ammo[i].height);

                       }

                       for(i=0; i<100; i++){
                        other_ammo[i] = new Sprite(bull);
                        other_ammo[i].x = 15;
                        other_ammo[i].y = 15;
                        other_ammo[i].scale.set(0.1,0.1);
                        other_ammo[i].anchor.set(0.5 ,0.5);
                        other_ammo[i].rotation -= Math.PI*0.5 ;
                        other_ammo[i].visible = false;
                       app.stage.addChild(other_ammo[i]);
                  }
                }


function make_grid(){
                     grid_t = TextureCache["tile.png"];
                     broke_t =TextureCache["broke.png"]
                     for(i=0; i<30; i++){
                       for(j=0; j<30; j++){
                         grid[i*30+j] = new Sprite(grid_t);
                         grid[i*30+j].height=30;
                         grid[i*30+j].width=30;
                         grid[i*30+j].x=30*j;
                         grid[i*30+j].y=30*i;
                         app.stage.addChild(grid[i*30+j]);
                         grid[i*30+j].visible=false;
                         grid2[i*30+j] = new Sprite(broke_t);
                         grid2[i*30+j].height=30;
                         grid2[i*30+j].width=30;
                         grid2[i*30+j].x=30*j;
                         grid2[i*30+j].y=30*i;
                         app.stage.addChild(grid2[i*30+j]);
                         grid2[i*30+j].visible=false;
                       }
                     }
                     //console.log("maze size "+bricks.length);
                     for(i=0; i<bricks.length; i++){
                         //console.log(bricks[i]);
                         grid[bricks[i]].visible=true;
                     }
                     for(i=0; i<broken.length; i++){
                       grid2[broken[i]].visible=true;
                     }
                  }


function detect_col(c_state) {
                             let x=(midx-15)/30, y=(midy-15)/30, l, r, d, u;
                             l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
                             r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
                             d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
                             u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
                          
                             //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
                             if(c_state == 38 && u)
                               return true;
                             else if(c_state == 40 && d)
                               return true;
                             else if(c_state == 37 && l)
                               return true;
                             else if(c_state ==39 && r)
                               return true;
                             else
                               return false;
                        }
function check_bul_col(c_state) {
                             x=(ammo[bulletcount-1].x-15+(ammo[bulletcount-1].x-15)%30)/30;
                             y=(ammo[bulletcount-1].y-15+(ammo[bulletcount-1].y-15)%30)/30;

                              
                             let l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
                             let r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
                             let d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
                             let u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
                             //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
                             
                             if(c_state == 38 && u){
                                 hit_wall =true;
                               ammo[bulletcount-1].visible =false;
                               if(grid2[x+(y-1)*30].visible)
                                 broken_tile =x+(y-1)*30;
                                 grid2[x+(y-1)*30].visible=false;
                               return true;
                             }
                             else if(c_state == 40 && d){
                                hit_wall =true;
                               ammo[bulletcount-1].visible =false;
                               if(grid2[x+(y+1)*30].visible)
                                 broken_tile =x+(y+1)*30;
                                 grid2[x+(y+1)*30].visible=false;
                               return true;
                             }
                             else if(c_state == 37 && l){
                               hit_wall =true;
                               ammo[bulletcount-1].visible =false;
                               if(grid2[(x-1)+y*30].visible)
                                 broken_tile =(x-1)+y*30;
                                 grid2[(x-1)+y*30].visible=false;
                               return true;
                             }
                             else if(c_state ==39 && r){
                              hit_wall =true;
                              ammo[bulletcount-1].visible =false;
                               if(grid2[x+1+y*30].visible)
                                 broken_tile  =(x+1)+y*30;
                                 grid2[x+1+y*30].visible=false;
                               return true;
                             }
                             else
                               return false;
}

function bulletmove(){
                         if(ammo[bulletcount-1].x > 920 || ammo[bulletcount-1].x <-10 || ammo[bulletcount-1].y>920 || ammo[bulletcount-1].y<-10 || bullet_fired == false){
                           //console.log("bm");
                           //bullet_fired=false;
                           return;
                         }
                         //angle=tank.rotation;
                         if(check_bul_col(bul_mov_state)){
                           ammo[bulletcount-1].visible = false;
                           console.log("bullet collided with wall")
                           bullet_fired = false;
                           state= play;
                         }
                         requestAnimationFrame(bulletmove);
                         ammo[bulletcount-1].x += 0.5*tank.vx*Math.sin(angle_1);
                         ammo[bulletcount-1].y -= 0.5*tank.vy* Math.cos(angle_1);

                         //console.log("bullet"+ bulletcount+" has been released "+ammo[bulletcount-1].x);
                         //ismoving =false ;
                    }


function idle(){
  
                if(healthbar ==0 && exit == false )
                {
                  healthbar =5 ;
                  healthstatus.outer.width =125;
                  attempts--;

                }

                 if(attempts == 0)
                 {
                 	//console.log("jsfbdsbfusd")
                   tank.visible =false ;
                   let x=bulletcount;
                   for(i=x; i<100; i++){
                   	ammo[bulletcount].visible=false;
                   	//console.log("bul_gone");
                   	bulletcount++;
                    }
                    //console.log("idle "+bulletcount);
                   healthstatus.outer.width=0;
                   exit = true ;

                 }
                 state = play ;

           }

function leftloop(){
                        if(leftflag === true)
                           {
                                 if(detect_col(37) && exit ==false){
                                   console.log("collision");
                                   healthbar-- ;
                                   collide.play();
                                   healthstatus.outer.width -=25 ;
                                   console.log("health decrease due to wall");
                                   idle();
                                   console.log("in the idle state ");
                                   console.log(healthbar);
                                 }
                               else{  
                                        
                                         tank.x-=tank.vx;
                                         center_x-=tank.vx;
                                         if(!ismoving)
                                        {
                                             for( i=bulletcount;i<100 ;i++ )
                                             {
                                               ammo[i].x -=tank.vx ;
                                             }
                                        }
                                      console.log("l "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                                      midx-=30;
                                }
                            }
                   }
 function rightloop(){
                         if(rightflag === true)
                         {
                           if(detect_col(39) && exit ==false)
                           {
                             console.log("collision");
                             healthbar-- ;
                             collide.play();
                             console.log("health decrease due to wall");
                             healthstatus.outer.width -=25 ;
                             idle();
                             console.log("in the idle state ");
                             console.log(healthbar);
                           }
                           else{
                                
                             tank.x+=tank.vx;
                             center_x+=tank.vx;
                               if(!ismoving)
                               {
                                 for( i=bulletcount;i<100 ;i++ )
                                 {
                                   ammo[i].x +=tank.vx ;
                                 }
                               }
                               //tank.rotation += 0.01 ;
                                console.log("r "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                                midx+=30;
                             }
                           }
                   }
 function uploop(){
                     if(upflag === true )
                     {
                       if(detect_col(38) && exit ==false){
                         console.log("collision");
                         healthbar-- ;
                         collide.play();
                         healthstatus.outer.width -=25 ;
                         console.log("health decrease due to wall");
                         idle();
                         console.log("in the idle state ");
                         console.log(healthbar);
                       }
                       else{
                           tank.y-=tank.vy;
                           center_y-=tank.vy;
                           if(!ismoving)
                           {
                             for( i=bulletcount;i<100 ;i++ )
                             {
                               ammo[i].y -=tank.vy ;
                             }
                           }
                           //tank.rotation -= 0.01 ;
                           console.log("u "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                           midy-=30;
                         }
                      }
                 }
 function downloop(){
                       if(downflag === true)
                       {   //requestAnimationFrame(downloop);
                         //setInterval(downloop,1000);
                         if(detect_col(40) && exit ==false){
                           console.log("collision");
                           healthbar-- ;
                           collide.play();
                           healthstatus.outer.width -=25 ;
                           idle();
                           console.log("health decrease due to wall");
                           //console.log("in the idle state ");
                           console.log(healthbar);
                         }
                         else{
                            tank.y+=tank.vy;
                            center_y += tank.vy;
                             if(!ismoving)
                             {
                               for( i=bulletcount;i<100 ;i++ )
                               {
                                 ammo[i].y +=tank.vy ;
                               }
                             }
                             //tank.rotation += 0.01 ;
                             console.log("d "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
                             midy+=30;
                           }
                         }
                   }

function keyboard(keyCode) {
         let key = {};
         key.code = keyCode;
         key.isDown = false;
         key.isUp = true;
         key.press = undefined;
         key.release = undefined;
         key.downHandler = event => {
           if (event.keyCode === key.code) {
             if (key.isUp && key.press) key.press();
             key.isDown = true;
             key.isUp = false;
           }
           event.preventDefault();
         };
         //The `upHandler`
         key.upHandler = event => {
           if (event.keyCode === key.code) {
             if (key.isDown && key.release) key.release();
             key.isDown = false;
             key.isUp = true;
           }
           event.preventDefault();
         };
         window.addEventListener(
           "keydown", key.downHandler.bind(key), false
         );
         window.addEventListener(
           "keyup", key.upHandler.bind(key), false
         );
         return key;
       }




function detect_tc()
{
    if( Math.pow(other_center_x -center_x ,2)  +   Math.pow(other_center_y - center_y ,2) <=900)
    {
        console.log("tank collision detected");
        return true;
    }
    return false;
}

function detect_tb()
{
    if(Math.pow(update.bullet_x -center_x ,2)  +   Math.pow(update.bullet_y -center_y ,2) <=450 && ammo[other_bulletcount-1].visible ==true){

      //console.log("bullet tank collision detected");
      console.log("health decrease due to detect_tb()");
      ammo[other_bulletcount-1].visible = false ;
      healthbar-- ;
      //collide.play();
      healthstatus.outer.width -=25 ;     
      idle();
      console.log("in the idle state ");
      console.log(healthbar);
       

    }


}


function check_tank_col(num){
  //console.log("tank_col "+num);
  if(midx < other_center_x && num == 1 && detect_tc()){
    console.log("tank_col "+1)
    return true;
  }
  else if(midx > other_center_x && num == 2 && detect_tc()){
    console.log("tank_col "+2)
    return true;
  }
  else if(midy < other_center_y && num == 3 && detect_tc()){
    console.log("tank_col "+3)
    return true;
  }
  else if(midy > other_center_y && num == 4 && detect_tc()){
    console.log("tank_col "+4)
    return true;
  }
  console.log("tank_col false "+midx+" "+other_center_x);
  return false;
}


function gameLoop(delta){
          if(lost ==true || won== true || exit==true)
         {
           return;
         }

         state(delta);
       }

function play(delta) {
        tank.vx = 30;
        tank.vy= 30;

         if (exit== true){

           for(i=0 ;i<100 ;i++){
             ammo[i].visible = false ;
             ammo[i].vx=0;
             ammo[i].vy= 0;
           }

           tank.visible = false;
           tank.vx =0;
           tank.vy =0;
            return ;}


          if(hitTestRectangle(tank ,treasure))
          {
              for(i=0 ;i<100 ;i++){
                ammo[i].visible = false ;
                tank.vx=0;
                tank.vy= 0;
              }
              for(i=0; i<bricks.length; i++){
                  //console.log(bricks[i]);
                  grid[bricks[i]].visible=false;
              }

              for(i=0; i<broken.length; i++){
                grid2[broken[i]].visible=false;
              }
              tank.visible =false;
              treasure.visible=false;
              dungeon.visible =false ;
              app.stage.addChild(message2);
              won =true ;
            return ;

          }

             
     

       }




 </script>
</body>

</html>


