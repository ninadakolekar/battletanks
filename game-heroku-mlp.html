<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Battle tanks </title>
</head>

<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.0/pixi.min.js"></script>

<script src="js/sound.js"></script>

<p id="demo"></p>

<script>

var leftflag =true ;
var rightflag =true ;
var myID;
var myIDset =false;
var angle_1;

var upflag =true;
var downflag=true;
var hit_wall =false;

var attempts =3;
var healthbar =5 ;

var exit = false ;
var bulletcount= 0;

var ismoving = false;
var won =false;
var lost=false;
var isloaded =false;
var bullet_shot =0;
var initiliase =true ;

var center_x=0;
var center_y =0;
var socket = new WebSocket("ws://localhost:8080");
var update;
var broken_tile=-1;
var x=0;
var y=0;
var iBar =[];
var oBar=[];


let Application = PIXI.Application,
   Container = PIXI.Container,
   loader = PIXI.loader,
   resources = PIXI.loader.resources,
   TextureCache = PIXI.utils.TextureCache,
   Sprite = PIXI.Sprite,
   Rectangle = PIXI.Rectangle;
   pi=Math.PI;

let app = new Application({
   width: 1300,
   height: 1300,
   antialiasing:true,
   transparent: true,
   resolution: 1
 }
);


let style = new PIXI.TextStyle({
  fontFamily: "Arial",
  fontSize: 36,
  fill: "white",
  stroke: '#ff3300',
  strokeThickness: 4,
  dropShadow: true,
  dropShadowColor: "#000000",
  dropShadowBlur: 4,
  dropShadowAngle: Math.PI / 6,
  dropShadowDistance: 6,
});

let style2 = new PIXI.TextStyle({
  fontFamily: "Arial",
  fontSize: 20,
  fontWeight: 'bold',
});


sounds.load([
  "sounds/movement.mp3",
  "sounds/collision.mp3"
]);

sounds.whenLoaded = load_comp;

document.body.appendChild(app.view);
let gamestart ,gameover;

let dungeon, tank, door, id, grid_t, state, move_state=38, midx, midy,healthstatus,bullet, angle, bullet_fired=false,d, bul_mov_state=38,movement ,collide,message1,message2,treasure, p1, p2, p3, p4;
let bricks=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,59,60,65,66,67,68,70,71,72,73,74,75,76,77,78,79,81,82,83,84,89,90,91,118,119,120,121,148,149,150,152,155,156,157,158,159,170,171,172,173,174,177,179,180,182,185,204,207,209,210,212,215,217,218,219,230,231,232,234,237,239,240,242,245,247,262,264,267,269,270,275,277,292,294,299,300,302,307,312,317,322,327,329,330,332,334,335,336,337,341,343,344,345,346,348,352,353,354,355,357,359,360,362,387,389,390,392,401,408,417,419,420,422,431,438,447,449];
let broken=[33,34,55,56,63,64,69,80,85,86,92,93,94,99,110,115,116,117,122,123,129,140,146,147,160,169,190,199,220,221,222,227,228,229,249,252,257,260,272,273,274,278,279,282,283,284,285,286,287,290,291,295,296,297,333,342,347,356,363,371,374,375,378,386,404,405,432,433,436,437];
let grid = []
let grid2 = [];
let ammo =[];
let other_ammo=[];
let other_tank=[] ,other_healthstatus= [], other_center_x =[] , other_center_y= [] ,other_bullet,other_bulletcount;
var setupDone = false;
var updateDone = false;


function sendUpdate() {
         var updateObject = {   

        "id":myID,
        "message":"updateResponse",
        "tank_x" :tank.x ,
        "tank_y" :tank.y ,
        "rotationIncrement":angle,
        "bulletCount":bulletcount ,
        "bullet_x":ammo[bullet_shot].x,
        "bullet_y":ammo[bullet_shot].y,
        "other_x":ammo[bulletcount].x,
        "other_y":ammo[bulletcount].y,
        "center_x":center_x,
        "center_y":center_y,
        "health": healthstatus.outer.width ,
        "exit": exit,
        "won": won,
        "tile_index":broken_tile ,
        "hitwall":hit_wall,
        "bullet_direction":bul_mov_state
        //"btc": 	//btc means bullet tank collision
        } ;

        angle=0;
        broken_tile=-1;
        //healthstatus.outer.width =0;

      socket.send(JSON.stringify(updateObject));

}


function applyUpdate(msg) {
    updateDone = false;
    update = msg ;

   if(msg.id != myID) {
    
       if(msg.exit==true){
      
      //console.log("exit...")

      for (var i = msg.bulletCount; i < 100; i++) { 

        other_ammo[msg.id*100 +i].visible =false;
      }

      other_tank[msg.id].visible =false;
      other_healthstatus[msg.id].outer.width = 0;
      
      return;
    }
    else {
      //console.log("other tank  visibe true");
      other_tank[msg.id].visible =true;
    }


    if(msg.rotationIncrement != 0) {

      for (var i = msg.bulletCount; i < 100; i++){ 
        other_ammo[msg.id*100+ i].visible =true ;
        other_ammo[msg.id*100+i].rotation += msg.rotationIncrement ;
        }
        //console.log("####################### BULLET ROTATED ###################")
      other_tank[msg.id].rotation += msg.rotationIncrement;
      //console.log("*********************TANK ROTATED ******************************")
      
    } 
    
    else {

      other_tank[msg.id].x = msg.tank_x;
      other_tank[msg.id].y = msg.tank_y;
      other_center_x[msg.id] = msg.center_x;
      other_center_y[msg.id] = msg.center_y; 
         
      for (var i = msg.bulletCount; i < 100; i++){
        other_ammo[msg.id*100+i].visible =true ;
        other_ammo[msg.id*100+i].x =msg.other_x ;
        other_ammo[msg.id*100+i].y =msg.other_y;
      }

    }

    other_bulletcount = msg.bulletCount;

    if(msg.bulletCount !== 0){
      other_ammo[ 100*msg.id + msg.bulletCount-1].x = msg.bullet_x;
      other_ammo[100*msg.id + msg.bulletCount-1].y =msg.bullet_y;
    /*if(msg.hitwall == true)
       { other_ammo[100*msg.id+msg.bulletCount-1].visible =false ;
         console.log("bullet has hit the wall");
         msg.hitwall =false ;
        }*/

        x_temp = (msg.bullet_x-15+(msg.bullet_x-15)%30)/30;
    	y_temp = (msg.bullet_y-15+(msg.bullet_y-15)%30)/30;

    	//console.log("apply "+msg.bullet_direction);

       if(check_bul_col_update(msg.bullet_direction, x_temp, y_temp, 100*msg.id + msg.bulletCount-1)){
       	//console.log("bullet of P "+msg.id+" collided with wall update");
       	other_ammo[100*msg.id+msg.bulletCount-1].visible =false ;
       }
  
     detect_tb();
       

    }

    other_healthstatus[msg.id].outer.width = msg.health;

    if(msg.tile_index !=-1)
    {
     grid2[msg.tile_index].visible =false;

    }
  
    
    //coll_tc();
 

    if(update.won == true)
          {
                for(i=0 ;i<100 ;i++){
                  ammo[i].visible = false ;
                  ammo[i].vx=0;
                  ammo[i].vy= 0;
                
                }

                for(i=0 ;i<400 ;i++){
                  other_ammo[i]=0;
                }

               for(i=0 ;i<=3 ;i++){
                  if(i!=myID)
                 {other_tank[i].visible =false;}

               }

                tank.visible = false;
                tank.vx =0;
                tank.vy =0;

                for(i=0; i<bricks.length; i++){
                   
                    grid[bricks[i]].visible=false;
                }

                for(i=0; i<broken.length; i++){
                  grid2[broken[i]].visible=false;
                }

                dungeon.visible =false ;
                app.stage.addChild(message1);
                lost =true;
          return ;

          }

  }



   updateDone = true;
}

socket.onopen = function(){
        alert("Websocket Connection Established!!");
        loader
        .add("images/sirowa.json")
        .load(setup);
};

socket.onmessage = function (evt){ 
                    var received_msg  = evt.data;
                    var msg_obj = JSON.parse(received_msg)
                    if(msg_obj.message == "requestUpdate") {if(setupDone==true) sendUpdate();}
                    else if(msg_obj.message == "notifyID") {var x = msg_obj.id; myID = x;myIDset=true;}
                    else if(msg_obj.message == "applyUpdate") { if(setupDone==true) {applyUpdate(msg_obj);} 
                    
                    }
};

 function load_comp(){

         movement = sounds["sounds/movement.mp3"];
         collide = sounds["sounds/collision.mp3"];
 }

function key_init(){

let   left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);
      w = keyboard(87);

left.press = () =>{     
                    if((check_tank_col(2) && (move_state == 37 || move_state == 39) ) || exit==true){
                      return;
                    }
                    
                    console.log("a1");
                    leftflag =true;
                    if(move_state == 37 || move_state == 39){
                      leftloop();
                    }
                    else{
                      rot(37);
                    }
                    tank.pivot.set(15,15);

                  };

left.release =() => {
                      console.log("a2");
                      leftflag =false ;
                    };


right.press=()=>{
                  if((check_tank_col(1) && (move_state == 37 || move_state == 39))|| exit==true ){
                        return;
                  }
                  console.log("a3");
                  rightflag =true ;

                  if(move_state == 37 || move_state == 39){
                      rightloop();
                  }
                  else{
                        rot(39);
                  }
                  
                  tank.pivot.set(15,15);
              } ;

right.release=()=>{
                    console.log("a4");
                    rightflag =false ;
                  } ;


up.press = () => {
                    if( (check_tank_col(4) && (move_state == 38 || move_state == 40)) ||exit ==true  ) {
                          return;
                        }
  
                    upflag=true
                    console.log("a5");
                    if(move_state == 38 || move_state == 40){
                      uploop();
                    }
                    else{
                      rot(38);
                    }
                    tank.pivot.set(15,15);
                };



up.release = () => {
                        console.log("a6");
                        upflag =false;
                    };


down.press = () => {
                      if((check_tank_col(3) && (move_state == 40 || move_state == 38))|| exit==true){
                              return;
                      }
                      
                      console.log("a7");
                      downflag =true;
                      if(move_state == 40 || move_state == 38){
                        downloop();
                      }
                      else{
                      rot(40);
                      }
                      tank.pivot.set(15,15);
                  };

down.release = () => {
                       console.log("a8");
                       downflag =false ;
                      };

w.press =()=>{  if(exit == true)
                   {return ;}
               if(bullet_fired){
                 return;
               }
               else if (bulletcount <100)
               { //ammo[bulletcount].visible =true ;
                 bullet_fired = true;
                 //ismoving== true ;
                 bullet_shot =bulletcount ;
                 bulletcount++;
                 angle_1=tank.rotation;
                 bulletmove();
                 console.log(bulletcount + " is the bulletcount");
                }
                else
                {
                      console.log("no ammo ");
                }
           }

}

function health_init(){

p1 = new PIXI.Text("Player 1",style2);
p2 = new PIXI.Text("Player 2",style2);
p3 = new PIXI.Text("Player 3",style2);
p4 = new PIXI.Text("Player 4",style2);

p1.position.set(1000,240);
p2.position.set(1000,330);
p3.position.set(1000,510);
p4.position.set(1000,600);

app.stage.addChild(p1);
app.stage.addChild(p2);
app.stage.addChild(p3);
app.stage.addChild(p4);



healthstatus  = new PIXI.DisplayObjectContainer();

let innerBar = new PIXI.Graphics();
innerBar.beginFill(0x000000);
innerBar.drawRect(0,0, 125, 8);
innerBar.endFill();
healthstatus.addChild(innerBar);

let outerBar = new PIXI.Graphics();
outerBar.beginFill(0xFF3300);
outerBar.drawRect(0, 0, 125, 8);
outerBar.endFill();
healthstatus.addChild(outerBar);
healthstatus.outer = outerBar;

  for(i=0 ;i<=3 ;i++){
    
  if(i!= myID)
  {
  other_healthstatus[i]= new PIXI.DisplayObjectContainer();
  iBar[i] = new PIXI.Graphics();
  iBar[i].beginFill(0x000000);
  iBar[i].drawRect(0,0, 125, 8);
  iBar[i].endFill();
  other_healthstatus[i].addChild(iBar[i]);

  oBar[i] = new PIXI.Graphics();
  oBar[i].beginFill(0xFF3300);
  oBar[i].drawRect(0, 0, 125, 8);
  oBar[i].endFill();
  other_healthstatus[i].addChild(oBar[i]);
  other_healthstatus[i].outer = oBar[i];
  }

}
  if(myID%4 == 0)
{

 healthstatus.position.set(1100,240);
 app.stage.addChild(healthstatus);
 other_healthstatus[1].position.set(1100, 330);
 other_healthstatus[2].position.set(1100, 510);
 other_healthstatus[3].position.set(1100, 600);

}
else if(myID%4 == 1){

  healthstatus.position.set(1100, 330);
  app.stage.addChild(healthstatus);
  other_healthstatus[0].position.set(1100,240);
  other_healthstatus[2].position.set(1100,510);
  other_healthstatus[3].position.set(1100,600);


}
else if(myID%4 == 2){
 
  healthstatus.position.set(1100,510);
  app.stage.addChild(healthstatus);
  other_healthstatus[0].position.set(1100,240);
  other_healthstatus[1].position.set(1100,330);
other_healthstatus[3].position.set(1100,600);

}
else if(myID%4 == 3){

  healthstatus.position.set(1100,600);
  app.stage.addChild(healthstatus);
  other_healthstatus[0].position.set(1100,240);
  other_healthstatus[1].position.set(1100, 330);
  other_healthstatus[2].position.set(1100, 510);
}

for(i=0 ;i<=3;i++)
{  if(i!==myID)
  {app.stage.addChild(other_healthstatus[i]);}
}
  


}


function completeMaze(){
  
  let ctr = bricks.length;

  for(i=bricks.length-1; i>-1; i--){
    bricks[ctr] = 899-bricks[i];
    ctr++;
  }

  ctr = broken.length

  for(i=broken.length-1; i>-1; i--){
    broken[ctr] = 899-broken[i];
    ctr++;
  }
}



function init(){

 completeMaze();
 message1 = new PIXI.Text("YOU LOST",style);
 message2 =new PIXI.Text("YOU WON",style);
 message1.position.set(450 ,450);
 message2.position.set(450,450);


 let dungeonTexture = TextureCache["ground.png"];
 dungeon = new Sprite(dungeonTexture);
 app.stage.addChild(dungeon);
 tank = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
for(i=0;i<=3;i++)
{ 
  other_tank[i] = new Sprite(resources["images/sirowa.json"].textures["tank12.png"]);
  other_tank[i].width=30;
  other_tank[i].height=30;
}

 bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);

 other_bullet = new Sprite( resources["images/sirowa.json"].textures["missile.png"]);

 treasure =  new Sprite( resources["images/sirowa.json"].textures["treasure.png"]);

 tank.width=30;
 tank.height=30;

 treasure.width =50;
 treasure.height =30;
 }


function setup() {

  init();

 while(!myIDset){};
 if(myID%4 == 0)
{
 tank.x = 30;
 tank.y=30;
 midx = 45;
 midy =45;
 center_x = 45;
 center_y =45;
 tank.tint = 0xff3300;
}
else if(myID%4 == 1){
  tank.x =840;
  tank.y=840;
  midx =855;
  midy=855;
  center_x =855;
  center_y =855;
  tank.tint=0x008000
}
else if(myID%4 == 2){
  tank.x =30;
  tank.y=840;
  midx =45;
  midy=855;
  center_x = 45;
  center_y = 855;
  tank.tint=0x0000FF
}
else if(myID%4 == 3){
	tank.x = 840;
	tank.y = 30;
	midx = 855;
	midy = 45;
	center_x = 855;
	center_y = 45;
}
treasure.x = 425 ;
 treasure.y =435 ;
 tank.vx = 4;
 tank.vy = 4;
 other_tank.vx =4;
 other_tank.vy =4;
 //tank.y = app.stage.height - tank.height;
 //app.stage.addChild(tank);
 //app.stage.addChild(other_tank);
 //app.stage.addChild(treasure);

treasure.x = 425 ;
treasure.y =435 ;

tank.vx = 4;
tank.vy = 4;
app.stage.addChild(tank);

for(i=0;i<=3;i++){
  if(i!=myID)
  {
   other_tank[i].vx =4;
   other_tank[i].vy =4;
   app.stage.addChild(other_tank[i]);
  }
 }

app.stage.addChild(treasure);

make_grid();
make_ammo();

health_init();
key_init();

state = play;
app.ticker.add(delta => gameLoop(delta));
setupDone = true;
console.log("end");

 }

 function hitTestRectangle(r1, r2) {

  //Define the variables we'll need to calculate
  let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

  //hit will determine whether there's a collision
  hit = false;

  //Find the center points of each sprite
  r1.centerX = r1.x + r1.width / 2;
  r1.centerY = r1.y + r1.height / 2;
  r2.centerX = r2.x + r2.width / 2;
  r2.centerY = r2.y + r2.height / 2;

  //Find the half-widths and half-heights of each sprite
  r1.halfWidth = r1.width / 2;
  r1.halfHeight = r1.height / 2;
  r2.halfWidth = r2.width / 2;
  r2.halfHeight = r2.height / 2;

  //Calculate the distance vector between the sprites
  vx = r1.centerX - r2.centerX;
  vy = r1.centerY - r2.centerY;

  //Figure out the combined half-widths and half-heights
  combinedHalfWidths = r1.halfWidth + r2.halfWidth;
  combinedHalfHeights = r1.halfHeight + r2.halfHeight;

  //Check for a collision on the x axis
  if (Math.abs(vx) < combinedHalfWidths) {

    //A collision might be occuring. Check for a collision on the y axis
    if (Math.abs(vy) < combinedHalfHeights) {

      //There's definitely a collision happening
      hit = true;
    } else {

      //There's no collision on the y axis
      hit = false;
    }
  } else {

    //There's no collision on the x axis
    hit = false;
  }

  //`hit` will be either `true` or `false`
  return hit;
};



 function rot(r_state){
                       angle=pi/2.0;
                       let final, x=0, y=0;
                       if(move_state == 38)
                       {
                         if(r_state == 37)
                         {
                            angle*=-1;
                            y=30;
                          }
                         else
                         {
                           x=30;
                         }
                      }
                       else if(move_state == 39)
                       {
                         if(r_state == 38)
                         {
                           angle*=-1;
                           x=-30;
                         }
                         else
                         {
                           y=30;
                         }
                       }
                       else if(move_state == 40)
                       {
                         if(r_state == 39)
                         {
                           angle*=-1;
                           y=-30;
                         }
                         else
                         {
                           x=-30;
                         }
                       }
                       else{
                         if(r_state == 40)
                         {
                           angle*=-1;
                           x=30;
                         }
                         else
                         {
                           y=-30;
                         }
                       }
                       //requestAnimationFrame()
                       tank.rotation+=angle;
                       tank.x+=x;
                       tank.y+=y;
                       for(i=bulletcount; i<100; i++){
                          ammo[i].rotation +=angle ;
                          //ammo[i].x+=x;
                          //ammo[i].y+=y;
                        }
                       bul_mov_state = r_state;
                       move_state = r_state;
                       //console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+angle+" "+pi+" "+Math.PI);
                       console.log("rot_done "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y+" "+move_state);
     }



function make_ammo(){
                      var bull = TextureCache["missile.png"];
                      for(i=0; i<100; i++){
                       ammo[i] = new Sprite(bull);
                       ammo[i].x =tank.x+15;
                       ammo[i].y =tank.y+15;
                       ammo[i].scale.set(0.1,0.1);
                       ammo[i].anchor.set(0.5 ,0.5);
                       ammo[i].rotation -= Math.PI*0.5 ;
                       app.stage.addChild(ammo[i]);
                        //console.log("positio of bullet : "+ ammo[i].w+" "+ammo[i].height);
                        console.log("size of bullet : "+ ammo[i].width +" "+ammo[i].height);

                       }

                       for(i=0; i<400; i++){
                        other_ammo[i] = new Sprite(bull);
                        other_ammo[i].x = 15;
                        other_ammo[i].y = 15;
                        other_ammo[i].scale.set(0.1,0.1);
                        other_ammo[i].anchor.set(0.5 ,0.5);
                        other_ammo[i].rotation -= Math.PI*0.5 ;
                        other_ammo[i].visible = false;
                       app.stage.addChild(other_ammo[i]);
                  }
                }


function make_grid(){
                     grid_t = TextureCache["tile.png"];
                     broke_t =TextureCache["broke.png"]
                     for(i=0; i<30; i++){
                       for(j=0; j<30; j++){
                         grid[i*30+j] = new Sprite(grid_t);
                         grid[i*30+j].height=30;
                         grid[i*30+j].width=30;
                         grid[i*30+j].x=30*j;
                         grid[i*30+j].y=30*i;
                         app.stage.addChild(grid[i*30+j]);
                         grid[i*30+j].visible=false;
                         grid2[i*30+j] = new Sprite(broke_t);
                         grid2[i*30+j].height=30;
                         grid2[i*30+j].width=30;
                         grid2[i*30+j].x=30*j;
                         grid2[i*30+j].y=30*i;
                         app.stage.addChild(grid2[i*30+j]);
                         grid2[i*30+j].visible=false;
                       }
                     }
                     //console.log("maze size "+bricks.length);
                     for(i=0; i<bricks.length; i++){
                         //console.log(bricks[i]);
                         grid[bricks[i]].visible=true;
                     }
                     for(i=0; i<broken.length; i++){
                       grid2[broken[i]].visible=true;
                     }
                  }



function detect_col(c_state) {

  let x=(midx-15)/30, y=(midy-15)/30, l, r, d, u;
  l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
  r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
  d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
  u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;

  //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);
  if(c_state == 38 && u)
    return true;
  else if(c_state == 40 && d)
    return true;
  else if(c_state == 37 && l)
    return true;
  else if(c_state ==39 && r)
    return true;
  else
    return false;


     }

function check_bul_col_update(c_state, x_t, y_t, index) {

    let l = grid[(x_t-1)+y_t*30].visible || grid2[(x_t-1)+y_t*30].visible;
    let r = grid[x_t+1+y_t*30].visible || grid2[x_t+1+y_t*30].visible;
    let d = grid[x_t+(y_t+1)*30].visible || grid2[x_t+(y_t+1)*30].visible;
    let u = grid[x_t+(y_t-1)*30].visible || grid2[x_t+(y_t-1)*30].visible;
    //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);

    console.log("update check "+c_state+" "+index+" "+x_t+" "+y_t);

    if(c_state == 38 && u){

    hit_wall =true;
    other_ammo[index].visible =false;
    grid2[x_t+(y_t-1)*30].visible=false;
    return true;

    }
    else if(c_state == 40 && d){

    hit_wall =true;
    other_ammo[index].visible =false;    
    grid2[x_t+(y_t+1)*30].visible=false;
    return true;

    }
    else if(c_state == 37 && l){

    hit_wall =true;
    other_ammo[index].visible =false;
    grid2[(x_t-1)+y_t*30].visible=false;
    return true;

    }
    else if(c_state ==39 && r){

    hit_wall =true;
    other_ammo[index].visible =false;
    grid2[x_t+1+y_t*30].visible=false;
    return true;

    }
    else{
    return false;}
}


function check_bul_col(c_state) {

    x=(ammo[bulletcount-1].x-15+(ammo[bulletcount-1].x-15)%30)/30;
    y=(ammo[bulletcount-1].y-15+(ammo[bulletcount-1].y-15)%30)/30;


    let l = grid[(x-1)+y*30].visible || grid2[(x-1)+y*30].visible;
    let r = grid[x+1+y*30].visible || grid2[x+1+y*30].visible;
    let d = grid[x+(y+1)*30].visible || grid2[x+(y+1)*30].visible;
    let u = grid[x+(y-1)*30].visible || grid2[x+(y-1)*30].visible;
    //console.log(c_state+" cords"+x+" "+y+" "+midx+" "+midy+" "+l+" "+r+" "+d+" "+u);

    if(c_state == 38 && u){

    hit_wall =true;
    ammo[bulletcount-1].visible =false;
    if(grid2[x+(y-1)*30].visible)
    broken_tile =x+(y-1)*30;
    grid2[x+(y-1)*30].visible=false;
    return true;

    }
    else if(c_state == 40 && d){

    hit_wall =true;
    ammo[bulletcount-1].visible =false;
    if(grid2[x+(y+1)*30].visible)
    broken_tile =x+(y+1)*30;
    grid2[x+(y+1)*30].visible=false;
    return true;

    }
    else if(c_state == 37 && l){

    hit_wall =true;
    ammo[bulletcount-1].visible =false;
    if(grid2[(x-1)+y*30].visible)
    broken_tile =(x-1)+y*30;
    grid2[(x-1)+y*30].visible=false;
    return true;

    }
    else if(c_state ==39 && r){

    hit_wall =true;
    ammo[bulletcount-1].visible =false;
    if(grid2[x+1+y*30].visible)
    broken_tile  =(x+1)+y*30;
    grid2[x+1+y*30].visible=false;
    return true;

    }
    else{
    return false;}
}

function bulletmove(){
  
  if(ammo[bulletcount-1].x > 920 || ammo[bulletcount-1].x <-10 || ammo[bulletcount-1].y>920 || ammo[bulletcount-1].y<-10 || bullet_fired == false){
    //console.log("bm");
    //bullet_fired=false;
    return;
  }
  //angle=tank.rotation;
  if(check_bul_col(bul_mov_state)){
    ammo[bulletcount-1].visible = false;
    console.log("bullet collided with wall")
    bullet_fired = false;
    state= play;
  }
  requestAnimationFrame(bulletmove);
  ammo[bulletcount-1].x += 0.5*tank.vx*Math.sin(angle_1);
  ammo[bulletcount-1].y -= 0.5*tank.vy* Math.cos(angle_1);

  //console.log("bullet"+ bulletcount+" has been released "+ammo[bulletcount-1].x);
  //ismoving =false ;
                    }


function idle(){
  
    if(healthbar ==0 && exit == false )
    {
      healthbar =5 ;
      healthstatus.outer.width =125;
      attempts--;
    }

    if(attempts == 0)
    {
      tank.visible =false ;
      let x=bulletcount;

      for(i=x; i<100; i++){
        ammo[i].visible=false;
      
        }
  
        healthstatus.outer.width=0;
        exit = true ;

      }
      
      state = play ;

           }

function leftloop(){

  if(leftflag === true)
      {
        if(detect_col(37) && exit ==false){
          console.log("collision");
          healthbar-- ;
          collide.play();
          healthstatus.outer.width -=25 ;
          console.log("health decrease due to wall");
          idle();
          console.log("in the idle state ");
          console.log(healthbar);
        }
       else{  
              
          tank.x-=tank.vx;
          center_x-=tank.vx;

            if(!ismoving)
          {
                for( i=bulletcount;i<100 ;i++ )
                {
                  ammo[i].x -=tank.vx ;
                }
          }

        console.log("l "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
        midx-=30;

          }
      }
}


 function rightloop(){

    if(rightflag === true)
    {
        if(detect_col(39) && exit ==false)
        {
          console.log("collision");
          healthbar-- ;
          collide.play();
          console.log("health decrease due to wall");
          healthstatus.outer.width -=25 ;
          idle();
          console.log("in the idle state ");
          console.log(healthbar);
        }

      else{
          
          tank.x+=tank.vx;
          center_x+=tank.vx;
          if(!ismoving)
          {
            for( i=bulletcount;i<100 ;i++ )
            {
              ammo[i].x +=tank.vx ;
            }
          }
          console.log("r "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
          midx+=30;

        }
    }
}

 function uploop(){

    if(upflag === true )
    {
        if(detect_col(38) && exit ==false){
          console.log("collision");
          healthbar-- ;
          collide.play();
          healthstatus.outer.width -=25 ;
          console.log("health decrease due to wall");
          idle();
          console.log("in the idle state ");
          console.log(healthbar);
        }
        else{
            tank.y-=tank.vy;
            center_y-=tank.vy;
            if(!ismoving)
            {
              for( i=bulletcount;i<100 ;i++ )
              {
                ammo[i].y -=tank.vy ;
              }
            }
            //tank.rotation -= 0.01 ;
            console.log("u "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
            midy-=30;
          }
    }
}


 function downloop(){

    if(downflag === true)
    {   //requestAnimationFrame(downloop);
      //setInterval(downloop,1000);
      if(detect_col(40) && exit ==false){
        console.log("collision");
        healthbar-- ;
        collide.play();
        healthstatus.outer.width -=25 ;
        idle();
        console.log("health decrease due to wall");
        //console.log("in the idle state ");
        console.log(healthbar);
      }
      else{
        tank.y+=tank.vy;
        center_y += tank.vy;
          if(!ismoving)
          {
            for( i=bulletcount;i<100 ;i++ )
            {
              ammo[i].y +=tank.vy ;
            }
          }
          //tank.rotation += 0.01 ;
          console.log("d "+tank.x+" "+tank.y+" "+tank.pivot.x+" "+tank.pivot.y);
          midy+=30;
        }
      }
}


function keyboard(keyCode){

      let key = {};
      key.code = keyCode;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      key.downHandler = event => {
        if (event.keyCode === key.code) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
        }
        event.preventDefault();
      };
      //The `upHandler`
      key.upHandler = event => {
        if (event.keyCode === key.code) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
        }
        event.preventDefault();
      };
      window.addEventListener(
        "keydown", key.downHandler.bind(key), false
      );
      window.addEventListener(
        "keyup", key.upHandler.bind(key), false
      );
      return key;
}

function detect_tc()
{
    if( Math.pow(other_center_x[update.id] -center_x ,2)  +  Math.pow(other_center_y[update.id] - center_y ,2) <=900)
    {
      console.log("tank collision detected");
      return true;
    }
    
    return false;
}

function detect_tb()
{
    if(Math.pow(update.bullet_x -center_x ,2)  +   Math.pow(update.bullet_y -center_y ,2) <= 900 && other_ammo[100*update.id + other_bulletcount-1].visible ==true){

      //console.log("bullet tank collision detected");
      console.log("health decrease due to detect_tb()");
      other_ammo[100*update.id + other_bulletcount-1].visible = false ;
      healthbar-- ;
      //collide.play();
      healthstatus.outer.width -=25 ;     
      idle();
      console.log("in the idle state ");
      console.log(healthbar);

    }


}


function check_tank_col(num){
  //console.log("tank_col "+num);
  if(midx < other_center_x[update.id] && num == 1 && detect_tc()){
    console.log("tank_col "+1)
    return true;
  }
  else if(midx > other_center_x[update.id] && num == 2 && detect_tc()){
    console.log("tank_col "+2)
    return true;
  }
  else if(midy < other_center_y[update.id] && num == 3 && detect_tc()){
    console.log("tank_col "+3)
    return true;
  }
  else if(midy > other_center_y[update.id] && num == 4 && detect_tc()){
    console.log("tank_col "+4)
    return true;
  }
  console.log("tank_col false "+midx+" "+other_center_x);
  return false;
}


function gameLoop(delta){

    if(lost ==true || won== true || exit==true)
    {  
      return;
    }

    state(delta);
}

function play(delta) {
  tank.vx = 30;
  tank.vy= 30;

  if (exit== true){

    for(i=0 ;i<100 ;i++){
      ammo[i].visible = false ;
      ammo[i].vx=0;
      ammo[i].vy= 0;
    }

    tank.visible = false;
    tank.vx =0;
    tank.vy =0;
    return ;
  }


  if(hitTestRectangle(tank ,treasure))
  {
      for(i=0 ;i<100 ;i++){
        ammo[i].visible = false ;
        tank.vx=0;
        tank.vy= 0;
      }
      for(i=0; i<bricks.length; i++){
          //console.log(bricks[i]);
          grid[bricks[i]].visible=false;
      }

      for(i=0; i<broken.length; i++){
        grid2[broken[i]].visible=false;
      }
      tank.visible =false;
      treasure.visible=false;
      dungeon.visible =false ;
      app.stage.addChild(message2);
      won =true ;
    return ;

  }

}




 </script>
</body>

</html>


